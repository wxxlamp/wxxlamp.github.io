<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="王星星"><title>百度三轮游 · 王星星的魔灯</title><meta name="description" content="记得那是周五，一天连着四轮面试（上午两场+下午两场），上午是百度一面和shopee，下午两轮全是百度的


一面
String，StringBuffer， StringBuilder

String是由final修饰的类，同时它是由byte(9+)或者char(8-)数组组成的，这些数组也是fina"><meta name="keywords" content="王星星的魔灯,博客,王星星"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">王星星的魔灯</a></h3><div class="description"><p>勇士斗恶龙 <br> Love & Seriousness & Regularity & Persistence</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/wxxlamp"><i class="fa fa-github"></i></a></li><li><a href="mailto:stalern2000@163.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2305450070&amp;site=qq&amp;menu=yes"><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/xiao-ming-91-8-39"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2018 - 2021 </span><i class="fa fa-star"></i><span> 王星星</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core-Plus  </a></div><div class="beian"><a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备20004458号-1</a><span style="height:10px;margin-left: 10px;">|</span><img src="/images/gongan.png" style="height:10px;margin-left: 10px;position: relative;top: 1px;"><span style="margin-left: 2px;">豫公网安备 44030400004458号</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>百度三轮游</a></h3></div><div class="post-content"><p>记得那是周五，一天连着四轮面试（上午两场+下午两场），上午是百度一面和shopee，下午两轮全是百度的</p>
<a id="more"></a>

<h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol>
<li><p>String，StringBuffer， StringBuilder</p>
<ul>
<li>String是由final修饰的类，同时它是由byte(9+)或者char(8-)数组组成的，这些数组也是final的</li>
<li>StringBuffer是线程安全的，StringBuilder是线程不安全的。StringBuffer是通过synchronized的方法级别来实现的</li>
<li>对于StringBuffer和StringBuilder来说，他们有一个共同的父类，即AbstractStringBuilder，他们的属性和类都没有final修饰，所以导致了他们是可变的。相对来说，StringBuffer有自己的cache，保证了查询的性能，这个cache在builder中是没有的。</li>
</ul>
</li>
<li><p>接口和抽象类</p>
<ul>
<li>在JDK5之前，接口和抽象类在语法层面上有着显著的区别：接口不能有自己的方法体，同时接口只能是public的；抽象类可以有自己实现的方法，同时抽象类也可以有空方法</li>
<li>随着JDK的升级，在Java8时，接口可以有default方法，到了Java9之后，接口也可以有自己的私有方法。接口除了属性默认是public final的之外，几乎和抽象类在语法层面，没有任何区别</li>
<li>所以对于这两者的区别，我们要站在更高的的角度，从设计的层面去看它们之间的区别。在我看来接口的设计是自上而下的，而抽象类的设计是自下而上的。设计模式中的模板方法模式，就是用抽象类的一个较好的体现。</li>
</ul>
</li>
<li><p>锁</p>
<ul>
<li>Java中的锁其实分为两大类，一个是悲观锁，一个是乐观锁。悲观锁指的是synchronized家族的，使用的时候包括<code>Object#notify()</code>、<code>Object#notifyAll()</code>和<code>Object#wait()</code>。乐观锁指的是由CAS包延伸出来的一系列锁，包括J.U.C中的<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>，与之配合使用的是<code>Condition</code></li>
<li>对于Synchronized来说，它的锁粒度是对象级别的，默认是Class对象，也可以是我们指定的实例对象。当修饰方法的时候会在字节码的flags中表明为ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，如果有设置，则需要先获得监视器锁。当修饰代码块时，会在字节码中通过 <code>monitorenter</code> 和 <code>monitorexit</code> 执行来进行加锁。当线程执行到 <code>monitorenter</code> 的时候要先获得所锁，才能执行后面的方法。Synchronized随着JDK的演变做出了一系列优化，如轻量级锁，锁粗化，锁消除，自旋锁等等。</li>
<li>对于<code>ReentrantLock</code>来说，是一种可重入锁。它对应两个内部类分别表示公平锁和非公平锁，都继承自Sync，而Sync继承自AQS。于公平锁的<code>tryAcquire()</code>来说，它比非公平锁多了一个<code>!hasQueuedPredecessors()</code>的判断，即检查如果<strong>当前线程位于队列的最前面或队列为空</strong>，才会让它获得锁</li>
<li>相对于Synchronized，ReentrantLock需要手动获取释放，支持公平锁，选择性通知等等功能。</li>
</ul>
</li>
<li><p>大概说下集合，hashMap的并发问题，HashMap中key为NULL时存的位置</p>
<ul>
<li>Java中的集合分为两部分，一个是java.util包下的集合，包括list,vector,map,set等，还有一个就是J.U.C包下的并发集合</li>
<li>对于list来说，分为数组存储和链表存储，分别是ArrayList和LinkedList（数组存储中还有vector，不过其效率较低一般不用）。对于Map来说，分为HashMap，WeakHashMap、TreeMap和LinkedHashMap。对于HashMap来说，它通过拉链法来解决hash冲突的问题；对于TreeMap来说，他通过红黑树来对key进行排序；对于LinkedHashMap来说，它通过链表记录了每个key插入的顺序，可以通过它实现LRU算法；对于WeakHashMap来说，它类似于ThreadLocal中的Entry，都继承了WeakReference，当key不被引用的时候，可以下次GC的时候删除；对于Set来说，它的几个派生类都是由对应Map实现的</li>
<li>HashMap在1.7版本时，当Entry数组多线程扩容时，因为使用的是头插法，会导致出现一个循环的单链表，导致get死循环的问题（1.8时已经修复）。除此之外，并发put元素时有可能导致覆盖问题。</li>
<li>HashMap中key为null，hash的结果是0，它会被保存在entry[0]上</li>
</ul>
</li>
<li><p>NIO和BIO</p>
<ul>
<li>Java目前为止支持3种IO，分别是BIO，NIO和AIO。BIO对应OS的阻塞式IO，NIO对应着OS中的多路复用模型，AIO则是异步IO模型。</li>
<li>阻塞式IO模型 BIO： 当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态，如<code>socket.accept()</code></li>
</ul>
<ul>
<li>IO复用模型 NIO(select,poll,epoll)：Java NIO之前用的select，现在用的epoll。用户发出IO请求之后，有一个select线程去管理这些请求*(socket)*，它会不断阻塞轮询内核关于某事件的数据是否能准备好，没有事件准备好则会一直阻塞。适合连接数较多的情况；select基于long数组，将内核和用户态拷贝消耗大，有1024的限制；poll基于链表，没有大小限制；epoll基于map，通过事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到ready队列里面，时间复杂度O(1)<br>需要注意的是：多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询</li>
</ul>
</li>
<li><p>线程状态及转换</p>
<ul>
<li>线程共有六种基本状态，分别是<code>NEW</code>，<code>RUNNABLE</code>，<code>BLOCKED</code>，<code>WAITING</code>，<code>TIMED_WAITING</code>，<code>TERMINATED</code></li>
<li><code>NEW</code>：线程被new出来，但是没有调用start方法</li>
</ul>
<ul>
<li><p><code>RUNNABLE</code>：分为运行态和就绪态。就绪态即在等待一些资源如CPU</p>
</li>
<li><p><code>BLOCKED</code>：等待monitor的锁，一般是要进入<code>synchronized</code>块或者方法中的线程。这对应着<code>synchronized</code>中对象的<code>MonitorObject</code>的<code>_EntryList</code>队列</p>
</li>
<li><p><code>WAITING</code>：当线程调用了<code>Object.wait()</code>,<code>Thread.join()</code>或者<code>LockSupport.park()</code>方法时，进入等待状态，直到使用<code>notify()</code>/<code>notifyAll()</code>,<code>LockSupport.unpark()</code>或者调用方法的线程结束</p>
</li>
<li><p><code>TIMED_WAITING</code>：是一种特殊的等待状态，当线程调用了<code>Thread.sleep(long)</code>,<code>Object.wait(long)</code>, <code>Thread.join(long)</code>, <code>LockSupport.parkNanos(long)</code>或者<code>LockSupport.parkUntil(long)</code>方法时，进入超时等待状态</p>
</li>
<li><p><code>TERMINATED</code>：线程已经完成执行，进入结束状态</p>
</li>
</ul>
</li>
<li><p>线程池</p>
<ul>
<li>线程池是一种池化技术，降低资源消耗，提高响应速度，提高现成的可管理性</li>
<li>线程池有七个参数，分别是<code>corePoolSize</code>,<code>maxmumPoolSize</code>,<code>keepAliveTime</code>,<code>unit</code>,<code>workQueue</code>,<code>threadFactory</code>,<code>handle</code>，当任务来临时，线程池的线程数会逐渐增大到core，然后把多余的放到队列中，如果超过队列长度，则增加线程池数目至max，如果还继续增加，则通过handle进行拒绝。当线程空闲time时间后，会销毁到core的数目。</li>
<li>J.U.C提供四种常见的线程池，分别是fixed（执行固定线程数目），single（执行单个任务），cache（执行多个短期任务）和scheduled（执行周期性任务）。前两个等待队列无限长，后两个最大线程数无限大</li>
</ul>
</li>
<li><p>缓存一致性</p>
<p>只要有缓存，就存在缓存和DB的一致性问题</p>
<ul>
<li>先更新数据库，再更新缓存的话：如果A更新数据库，接着B更新数据库，接着B更新缓存，接着A更新缓存，造成了数据库和缓存不一致的情况；同样，先更新缓存，后更新数据库也有一样的问题</li>
<li>先删除缓存，再更新数据库：如果A删除了缓存，接着B去查数据库，B把脏值填入缓存中，A再更新数据库，此时缓存已经有值了，导致缓存和数据库不一致</li>
<li>采用延时双删的方案，即先删除缓存，再更新数据库，然后延时再删除缓存。当缓存删除失败的时候，可以将失败的key发送至消息队列，重新消费</li>
</ul>
</li>
<li><p>有序数组的合并</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] arrA, <span class="keyword">int</span>[] arrLeft) &#123;</span><br><span class="line">        <span class="keyword">int</span> aLen = arrOne.length, bLen = arrB.length;</span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[aLen + bLen];</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; aLen + bLen; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a &lt; aLen &amp;&amp; b &lt; bLen) &#123;</span><br><span class="line">                ans[i] = arrA[a] &gt; arrB[b] ? arrB[b ++] ? arrA[a ++];</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; aLen) &#123;</span><br><span class="line">                ans[i] = arrA[a ++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b &lt; bLen) &#123;</span><br><span class="line">                ans[i] = arrB[b ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol>
<li><p>数据库索引</p>
<ul>
<li>对于MySQL来说，其索引是B+树的结构，二叉搜索树保证了索引是有序的，平衡二叉树保证了索引不会退化到链表的极端情况，B树降低了平衡二叉树的严格性，提高了构建效率，B+树将值放到叶子节点中，是的树变矮，提高IO效率</li>
<li>除此B+树之外，还有Hash索引，全文索引，R-Tree索引。可以通过B+Tree索引创建业务性质的自适应Hash索引（这个Innodb也有一定的优化，其中腾讯在11月份还贡献了点优化的代码，详情可以查看腾讯技术工程公众号#一个即将写入MySQL源码的官方bug解决之路）</li>
<li>索引还有一些概念如：聚簇索引，组合索引，主键索引，索引下推，唯一索引，最左原则，覆盖索引 ，前缀索引</li>
<li>一些索引失效的场景包括：like违背最左原则，类型不匹配，使用！等</li>
</ul>
</li>
<li><p>AQS</p>
<ul>
<li>QS通过内置的FIFO双端双向链表来完成获取资源线程的排队工作，双端双向链表。该队列由一个一个的<code>Node</code>结点组成，每个<code>Node</code>结点维护一个<code>prev</code>引用和<code>next</code>引用，分别指向自己的前驱和后继结点。AQS维护两个指针，分别指向队列头部<code>head</code>和尾部<code>tail</code>。该队列中的<code>Node</code>有五种状态，分别是<code>CANCELLED</code>,<code>SIGNAL</code>, <code>CONDITION</code>,<code>PROPAGATE</code>和初始状态</li>
<li>从使用上来说，AQS的功能可以分为两种：独占（如<code>ReentrantLock</code>）和共享（如<code>Semaphore</code>/<code>CountDownLatch </code>,<code>CyclicBarrier</code>/<code>ReadWriteLock</code>)。<code>ReentrantReadWriteLock</code>可以看成是组合式，它对读共享，写独占</li>
<li>除了<code>ReentrantLock</code>外，还有三种常用的AQS组件，分别是<code>Semaphore</code>,<code>CountDownLatch</code>和<code>CyclicBarrier</code></li>
</ul>
</li>
<li><p>字段太长为什么不去建立索引</p>
<ul>
<li>字段过长的话会使得索引的存储变得很大，同时查找起来也会降低效率</li>
<li>所以我们不如使用前缀索引来尽可能降低索引的长度</li>
</ul>
</li>
<li><p>写一个LRU，并发的LRU该怎么写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个双向链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Integer key;</span><br><span class="line">        Integer value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer key, Integer value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来快速定位节点和记录节点数量</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="keyword">private</span> Node dummyFirst;</span><br><span class="line">    <span class="comment">// 虚拟尾节点</span></span><br><span class="line">    <span class="keyword">private</span> Node dummyLast;</span><br><span class="line">    <span class="comment">// LRU的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capacity 指定缓存的容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">        dummyFirst = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        dummyLast = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 建立虚拟头和虚拟尾节点的关系</span></span><br><span class="line">        dummyFirst.next = dummyLast;</span><br><span class="line">        dummyLast.pre = dummyFirst;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从缓存中获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 缓存的键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 缓存的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果map中没有这个key,证明没有命中缓存,直接返回-1即可</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node target = map.get(key);</span><br><span class="line">        <span class="comment">// 将命中缓存的节点移到链表的最末尾（虚拟尾节点前面）</span></span><br><span class="line">        moveToTail(target, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向缓存中写入数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 写入的键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 写入的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果这个map存在的话,只需要把这个节点移到链表的最末尾（虚拟尾节点前面）,并修改链表的值即可</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            moveToTail(map.get(key), <span class="keyword">false</span>);</span><br><span class="line">            map.get(key).value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果map不存在的话,需要在map和链表的最末尾（虚拟尾节点前面）新增这个节点,并且检查现在缓存超没超容量,如果超了的话需要删除链表的最前面的节点(虚拟头节点的后面)</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        map.put(key, node);</span><br><span class="line">        moveToTail(node, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">while</span> (map.size() &gt; capacity) &#123;</span><br><span class="line">            map.remove(dummyFirst.next.key);</span><br><span class="line">            dummyFirst.next = dummyFirst.next.next;</span><br><span class="line">            dummyFirst.next.pre = dummyFirst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将节点移动至链表的末尾，假末尾节点前面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToTail</span><span class="params">(Node node, <span class="keyword">boolean</span> insert)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果不是新增,而是修改,我们要维护原节点的pre和next节点的next和pre引用</span></span><br><span class="line">        <span class="keyword">if</span> (!insert) &#123;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点移动到链表的最末尾（虚拟尾节点前面）</span></span><br><span class="line">        node.next = dummyLast;</span><br><span class="line">        node.pre = dummyLast.pre;</span><br><span class="line">        dummyLast.pre = node;</span><br><span class="line">        node.pre.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ol>
<li><p>分布式锁</p>
<ul>
<li>对于单机的锁来说，它只是一个所有线程/进程都能看到的一个<strong>标记</strong>而已。对于Java来说，synchronized是在对象头设置标记，Lock 接口的实现类基本上都只是某一个 volitile 修饰的 int 型变量其保证每个线程都能拥有对该 int 的可见性和原子修改；对于linux内核中来说，它也是利用互斥量或信号量等内存数据做标记。</li>
<li>对于分布式情况来说，我们只要能找到一个公共标记被所有机器可以访问，就可以通过这个标记来完成分布式锁的性质。我们可以把这个标记放到公共内存中，如Redis，Memcache；也可以放在磁盘上，如数据库中；</li>
<li>有了标记之后，我们要考虑这个分布式锁的性质，如是否可重入，是否公平，是否阻塞；考虑这个分布式锁的高可用和高性能；考虑这个分布式锁的实现方式，如乐观锁，悲观锁等等</li>
<li> 可以基于数据库的主键和版本号，Redis的SETNX()、EXPIRE()方法做分布式锁，也可以用Zookeeper来构建分布式锁</li>
</ul>
</li>
<li><p>集群的发现</p>
<ul>
<li>很多的中间件设计都会使用Zookeeper作为集群中组成员的发现机制，客户端会在Zookeeper上建立一个临时目录，Zookeeper会和客户端建立一条长连接，并且定时发送心跳，一旦发现客户端失活，Zookeeper就会删除当前客户端建立的临时节点，同时将消息发送给监听者。Zookeeper的这种特性被很多中间件应用作为集群发现机制。比如kafka使用Zookeeper维护broker和消费组的状态，Hbase使用Zookeeper选举集群的master，dubbo使用Zookeeper维护各个服务的实例存活状态（这个是从网上舶来的，因为我当时没理解面试官的意思，所以这个问题其实跳过了）</li>
</ul>
</li>
<li><p>broker到consumer的消息不丢失</p>
<ul>
<li><p>MQ的消息流程分为producer-&gt;broker-&gt;consumer，要保证消息不丢失，需要保证这两个传递过程的可靠性。面临的不稳定因素有网络异常，节点宕机等等。</p>
</li>
<li><p>RocketMQ采用了ack机制，如果consumer消费不到消息，broker会重复投递这个消息（投递次数可以自定义），直到消费成功，这里要保证消费接口的幂等性；同时，Consumer自身维护一个持久化的offset，标记这已经成功发回broker的下标 ，通过这个下标，即使Consumer宕机，也可以在重启之后到MessageQueue中拉去消息</p>
</li>
</ul>
</li>
<li><p>aop的两种实现和原因</p>
<ul>
<li>Spring AOP使用jdk动态代理和cglib。如果被继承者有接口的时候，使用JDK的动态代理，否则，则使用CGLIB</li>
<li>JDK的动态代理需要实现一个公共的接口（通过接口找到代理的方法），动态代理生成的反射类。Proxy是具体的代理，我们在实现了InvocationHandler之后的invoke方法会进入Proxy(<em>继承了Proxy，实现了接口</em>)的方法中</li>
<li>CGLib采用的是用创建一个继承实现类的子类，用asm库动态修改子类的代码来实现的，所以可以用传入的类引用执行代理类</li>
</ul>
</li>
<li><p>对称二叉树</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Scanner in = new Scanner(System.in);</span></span><br><span class="line">        <span class="comment">//int a = in.nextInt();</span></span><br><span class="line">        <span class="comment">//System.out.println(a);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> left.val == right.val &amp;&amp; dfs(left.left, right.right) &amp;&amp; dfs(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>从三轮面试情况来看，面试官随着级别的不同，问的问题也约偏架构，但是算法永远是不变的一个点。建议大家刷刷LeetCode。</p>
<p>整个秋招我面试了国内很多的互联网公司，经历的面试大概有30+场，在接下来的日子里，我会把这些笔记慢慢发布出来，供大家准备春招和实习。其实大约三个月没有面试了，上面这些问题我都有些不知道了，所以还是告诫我们，要持续学习！</p>
<p>其实后续我计划把我的面试帖子整理成PDF，大概分为面试步骤、常见面试题、我的面试经历、必刷算法、OFFER选择四个模块。希望不会咕咕</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-10-15</span><i class="fa fa-tag"></i><a class="tag" href="/categories/面试经验/" title="面试经验">面试经验 </a><a class="tag" href="/tags/Interview/" title="Interview">Interview </a><a class="tag" href="/tags/Java/" title="Java">Java </a><a class="tag" href="/tags/Campus-Recruitment/" title="Campus Recruitment">Campus Recruitment </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://wxxlamp.cn/2020/10/15/baidu-interview/,王星星的魔灯,百度三轮游,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/10/17/university-review/" title="我的大学">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/10/15/just-talk/" title="最近小感">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'VzGOJC7bFNXeYUEicbM4nOT2-gzGzoHsz',
  app_key:'T3VwGNzVqiWepoUHUQMnh8tP',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>