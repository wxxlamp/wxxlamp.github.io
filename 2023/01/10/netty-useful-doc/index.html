<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="王星星"><title>Netty可用性剖析 · 王星星的魔灯</title><meta name="description" content="Netty使用起来非常简单，不用像写Java原生的NIO一样， 各种Select的监听和处理；同时，也无需处理Java NIO自身的各种BUG；以及网络编程中的各种坑，如TCP的沾包拆包问题等。同时，各种网络协议也是网络编程的复杂之一，Netty也会帮助我们处理各种疑难问题。下面我们来具体分析：
N"><meta name="keywords" content="王星星的魔灯,博客,王星星"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><!-- 增加网站logo--><link rel="shortcut icon" href="/assets/img/favicon.ico" type="image/x-icon"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">王星星的魔灯</a></h3><div class="description"><p>勇士斗恶龙 <br> Love & Seriousness & Regularity & Persistence</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/wxxlamp"><i class="fa fa-github"></i></a></li><li><a href="mailto:wxxlamp@foxmail.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2305450070&amp;site=qq&amp;menu=yes"><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/coder_what"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"><span>© 2018 - 2023</span><i class="fa fa-star"></i><span> 王星星</span><!--span.leancloud_visitors--></div><div class="by_farbox"><span>Powered by</span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a><span> &</span><a href="https://github.com/wxxlamp/anatole-core-wxx" target="_blank">Anatole-Wxx</a></div><div class="beian"><a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备20004458号-1</a><span style="height:10px;margin-left: 10px;">|</span><img src="/images/gongan.png" style="height:10px;margin-left: 10px;position: relative;top: 1px;"><span style="margin-left: 2px;">豫公网安备 44030400004458号</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/categories">分类</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Netty可用性剖析</a></h3></div><div class="post-content"><p>Netty使用起来非常简单，不用像写Java原生的NIO一样， 各种Select的监听和处理；同时，也无需处理Java NIO自身的各种BUG；以及网络编程中的各种坑，如TCP的沾包拆包问题等。<br>同时，各种网络协议也是网络编程的复杂之一，Netty也会帮助我们处理各种疑难问题。<br>下面我们来具体分析：</p>
<h2 id="Netty的系统架构"><a href="#Netty的系统架构" class="headerlink" title="Netty的系统架构"></a>Netty的系统架构</h2><p>Netty从逻辑架构上可以分为三层，分别是通信层，职责链层和业务层。通信层负责通信处理；责任链层负责不同节点的编排，同时还会处理基础的逻辑，如编解码，POJO对象转换，心跳发送等等；而业务层就是单纯的负责上层业务的开发处理</p>
<p><img src="/assets/post/netty-useful-doc-1.png" alt="Netty架构图"></p>
<p>其中，三层的主要分工如下：<br><strong>通信层</strong>：该层主要包含NioSocketChannel和NioServerSocketChannel用来和Socket的连接，通过Reactor模型来处理高并发请求。该层的主要职责是监听网络的读写和连接操作，负责将网络层的数据读取到内存缓冲区中，然后出发各种网络事件，例如连接，读/写等事件，将这些事件触发到pipeline中，由pipeline来进行后续处理。<br><strong>职责链层</strong>：它负责事件在职责链中的有序传播，同时负责动态地编排职责链。通过不同的Handler来处理不同的基础情况，譬如，编解码处理器，POJO 对象转换器，粘包拆包处理器，心跳发送器，权限验证器等，这样上层业务则只需要关心处理业务逻辑即可，不需要感知底层的协议差异和线程模型差异，实现了架构层面的分层隔离。<br><strong>业务层</strong>：业务逻辑编排层通常有两类：一类是纯粹的业务逻辑编排，还有一类是其他的应用层协议插件，用于特定协议相关的会话和链路管理。</p>
<h2 id="易用的脚手架"><a href="#易用的脚手架" class="headerlink" title="易用的脚手架"></a>易用的脚手架</h2><h3 id="Java原生IO"><a href="#Java原生IO" class="headerlink" title="Java原生IO"></a>Java原生IO</h3><p>Java的原生IO编写起来是十分复杂的，而且Java的BIO和NIO的编写方案也完全不相同，如果一个项目刚开始为了图省事使用的是BIO，当项目业务量起来之后，如果也切换到NIO，就会十分痛苦。同时Java原生的NIO，处理起来也非常麻烦，需要感知许多select的事件，同时需要自己分配线程去处理业务逻辑</p>
<h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BioServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">1234</span>)) &#123;</span><br><span class="line">            <span class="comment">//创建服务器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动……&quot;</span>);</span><br><span class="line">            <span class="comment">//循环等待连接多个客户端</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = server.accept();</span><br><span class="line">                <span class="comment">// 读取输入流</span></span><br><span class="line">                <span class="keyword">try</span>(BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">                    PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    String body;</span><br><span class="line">                    body = in.readLine();</span><br><span class="line">                    out.println(body);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启多路复用器</span></span><br><span class="line">            Selector selector = Selector.open();</span><br><span class="line">            <span class="comment">// 开启服务器</span></span><br><span class="line">            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">            serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">1234</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;服务器已启动……&quot;</span>);</span><br><span class="line">            <span class="comment">// 设置服务器非阻塞</span></span><br><span class="line">            serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 将ServerSocketChannel注册到Selector上，监听 OP_ACCEPT 事件</span></span><br><span class="line">            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> select = selector.select();</span><br><span class="line">                <span class="comment">// 当有事件发生的时候，处理事件</span></span><br><span class="line">                <span class="keyword">if</span> (select &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">                    <span class="keyword">for</span> (SelectionKey selectionKey : selectionKeys) &#123;</span><br><span class="line">                        <span class="comment">// 如果是连接事件</span></span><br><span class="line">                        <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                            ServerSocketChannel serverSocket = (ServerSocketChannel) selectionKey.channel();</span><br><span class="line">                            <span class="comment">// 接收客户端连接，并且设置非阻塞，然后注册SocketChannel到多路复用器上，监听读事件</span></span><br><span class="line">                            SocketChannel socketChannel = serverSocket.accept();</span><br><span class="line">                            System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;已连接&quot;</span>);</span><br><span class="line">                            socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">// 如果有可读事件，那么处理数据</span></span><br><span class="line">                            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                            ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                            <span class="keyword">int</span> read = socketChannel.read(byteBuffer);</span><br><span class="line">                            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                String msg = <span class="keyword">new</span> String(byteBuffer.array(), StandardCharsets.UTF_8);</span><br><span class="line">                                System.out.println(socketChannel.getRemoteAddress() + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                                socketChannel.close();</span><br><span class="line">                                System.out.println(socketChannel.getLocalAddress() + <span class="string">&quot;断开连接&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Netty的Bootstrap"><a href="#Netty的Bootstrap" class="headerlink" title="Netty的Bootstrap"></a>Netty的Bootstrap</h3><p>Netty通过自己的脚手架Bootstrap解决了上面的问题，通过Bootstrap，我们可以轻松的选择NIO还是BIO，选择线程模型，选择绑定的端口以及对应的业务逻辑处理器<br>如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">        serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                <span class="comment">// channel fact</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">// 服务端 accept 队列的大小</span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                <span class="comment">// TCP Keepalive 机制，实现 TCP 层级的心跳保活功能</span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">// 允许较小的数据包的发送，降低延迟</span></span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .childHandler(<span class="keyword">new</span> ChildChannelHandler());</span><br><span class="line">        ChannelFuture f = serverBootstrap.bind(<span class="number">1234</span>).sync();</span><br><span class="line">        <span class="comment">// 绑定端口，并同步等待成功，即启动服务端</span></span><br><span class="line">        <span class="keyword">if</span> (f.isSuccess()) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;[start][Netty Server 启动在 &#123;&#125; 端口]&quot;</span>, <span class="number">1234</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于事件的过滤器模式"><a href="#基于事件的过滤器模式" class="headerlink" title="基于事件的过滤器模式"></a>基于事件的过滤器模式</h2><p>Netty的很多逻辑处理都是基于过滤器模式的，如下所示：<br><img src="/assets/post/netty-useful-doc-2.png" alt="image.png"><br>当一个请求进入Netty之后，Netty会把该请求封装成对应的channel，然后将该channel以过滤器模型的方式在pipeline中流转。在流转的过程中，该channel会经历不同的Handler，这些handler有负责编解码的，也有负责不同业务自定义处理的等等，当所有Handler都执行完了之后，就会将结果的报文返回给调用方。<br>可以看出，通过过滤器模式，Netty的不同Handler之间实现解耦，翻开Netty的源码我们就能发现，Netty内置了很多Handler来做报文的组装和拦截。当业务有自定义的逻辑的时候，直接新增Handler即可，完全解耦，不会对其他逻辑造成影响</p>
<h2 id="TCP流导致上层粘包和拆包问题"><a href="#TCP流导致上层粘包和拆包问题" class="headerlink" title="TCP流导致上层粘包和拆包问题"></a>TCP流导致上层粘包和拆包问题</h2><h3 id="粘拆包原因"><a href="#粘拆包原因" class="headerlink" title="粘拆包原因"></a>粘拆包原因</h3><p>在TCP/IP网络模型中，因为TCP协议在传输层，主要是对数据进行打包传输的，它并没有能力区分业务层的报文段（如基于TCP的HTTP协议等），参考Netty官网的文档：</p>
<blockquote>
<p>In a stream-based transport such as TCP/IP, received data is stored into a socket receive buffer. Unfortunately, the buffer of a stream-based transport is not a queue of packets but a queue of bytes. It means, <strong>even if you sent two messages as two independent packets, an operating system will not treat them as two messages but as just a bunch of bytes</strong>. Therefore, there is no guarantee that what you read is exactly what your remote peer wrote</p>
</blockquote>
<p>通俗来说，就是send和recv其实是根据以字节为单位传输的，同时，对于TCP协议来讲，因为TCP会根据滑动窗口弹性的发送不同长度的字节数，导致上层协议没有办法区分到底发送完没有。<br>本质上说，TCP是不存在粘包和拆包的，因为TCP协议根本没有“包”这个概念，粘包和拆包，也不能说是TCP协议的问题，这本来就是需要应用层自己解决的事情。<br>举个例子：<br><img src="/assets/post/netty-useful-doc-3.png" alt="image.png"><br>从上面的图中，我们可以看到，正常的业务报文应该是msg1（包含byte1和byte2），msg2（包含byte3和byte4），但是因为TCP是根据byte发的，所以就很有可能发成msg1(byte1)，msg2（byte2&amp;byte3&amp;byte4），这样就会导致我们所说的粘包和拆包问题<br>所以，针对TCP的粘包和拆包问题，是网络编程中一个必须要解决的问题。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于粘包和拆包问题，一般都是对包的格式进行约束，常见的解决方案有四种：</p>
<ul>
<li>将业务层协议包的长度固定下来，每个包都固定长度，比如512个字节大小，如果客户端发送的数据长度不足512个字节，则通过补充空格的方式补全到指定长度；</li>
<li>在每个包的末尾使用固定的分隔符，如换行符/n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并即可；</li>
<li>仿照TCP/IP协议栈，将消息分为head和body，在head中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；</li>
<li>通过自定义协议进行粘包和拆包的处理。</li>
</ul>
<h3 id="Netty的解决之道"><a href="#Netty的解决之道" class="headerlink" title="Netty的解决之道"></a>Netty的解决之道</h3><p>对于Netty来说，它的解决方案理念和刚才梳理的是一样的，不过Netty把这些解决方案融入到了自己的代码库中，我们可以基于Handler，直接开箱即用，如下所示：</p>
<ol>
<li>按照换行符切割报文：LineBasedFrameDecoder</li>
<li>按照自定义分隔符符号切割报文：DelimiterBasedFrameDecoder </li>
<li>按照固定长度切割报文：FixedLenghtFrameDecoder</li>
</ol>
<p>这些解决方案全被封装到了handler中，我们可以基于Netty的责任链模式，进行如下调用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">    <span class="comment">// channel fact</span></span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">            ch.pipeline.addLast(<span class="keyword">new</span> FixedLenghtFrameDecoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h2 id="易用的Buffer"><a href="#易用的Buffer" class="headerlink" title="易用的Buffer"></a>易用的Buffer</h2><p>在网络编程中，基本都是基于TCP报文的字节流的操作，所以Java的NIO又新增了ByteBuffer，只不过Java原生的ByteBuffer，非常难操作，也不能扩缩容，所以Netty又重新封装了自己的Bytebuf，除了性能上的优势之外，Netty的Buffer在使用上相对于NIO也非常简洁，有如下特点：</p>
<h3 id="动态扩缩容"><a href="#动态扩缩容" class="headerlink" title="动态扩缩容"></a>动态扩缩容</h3><p>顾名思义，Netty中的ByteBuffer可以像Java中的ArrayList一样，根据写入数据的字节数量，自动扩容。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ensureWritable0</span><span class="params">(<span class="keyword">int</span> minWritableBytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> writerIndex = writerIndex();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> targetCapacity = writerIndex + minWritableBytes;</span><br><span class="line">    <span class="comment">// using non-short-circuit &amp; to reduce branching - this is a hot path and targetCapacity should rarely overflow</span></span><br><span class="line">    <span class="keyword">if</span> (targetCapacity &gt;= <span class="number">0</span> &amp; targetCapacity &lt;= capacity()) &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkBounds &amp;&amp; (targetCapacity &lt; <span class="number">0</span> || targetCapacity &gt; maxCapacity)) &#123;</span><br><span class="line">        ensureAccessible();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(String.format(</span><br><span class="line">                <span class="string">&quot;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&quot;</span>,</span><br><span class="line">                writerIndex, minWritableBytes, maxCapacity, <span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalize the target capacity to the power of 2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fastWritable = maxFastWritableBytes();</span><br><span class="line">    <span class="keyword">int</span> newCapacity = fastWritable &gt;= minWritableBytes ? writerIndex + fastWritable</span><br><span class="line">            : alloc().calculateNewCapacity(targetCapacity, maxCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Adjust to the new capacity. 【此处进行扩容】</span></span><br><span class="line">    capacity(newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个在编写代码的时候，满足ByteBuf最大缓冲区的情况下，我们可以毫无顾忌地调用#write方法增加字节，而不用手动去check容量满足，然后去重新申请</p>
<h3 id="读写指针代替-filp"><a href="#读写指针代替-filp" class="headerlink" title="读写指针代替#filp"></a>读写指针代替#filp</h3><h4 id="原生ByteBuffer的弊端"><a href="#原生ByteBuffer的弊端" class="headerlink" title="原生ByteBuffer的弊端"></a>原生ByteBuffer的弊端</h4><p>Java原生的ByteBuffer的数据结构，分为limit，capacity两个指针，如果我们写入“Hollis”之后，ByteBuffer的内容如下：<br><img src="/assets/post/netty-useful-doc-4.png" alt="image.png"><br>此时，如果我们要从该ByteBuffer中read数据，ByteBuffer会默认从position开始读，这样就什么也读不到，所以我们必须调用#filp方法，将position指针移动，如下：<br><img src="/assets/post/netty-useful-doc-5.png" alt="image.png"><br>这样我们才可以读到“Hollis”这个数据，万一我们调用的时候忘记使用filp，就会很坑爹。</p>
<h4 id="Netty的ByteBuf"><a href="#Netty的ByteBuf" class="headerlink" title="Netty的ByteBuf"></a>Netty的ByteBuf</h4><p>Netty自带的ByteBuf通过读写双指针避免了上面的问题，假如我们写入“Hollis”后，ByteBuf的内容如下：<br><img src="/assets/post/netty-useful-doc-6.png" alt="image.png"><br>在写入的同时，我们可以直接通过readPointer读取数据，如下所示：<br><img src="/assets/post/netty-useful-doc-7.png" alt="image.png"><br>在这个过程中，我们完全不用像JavaNIO的ByteBufer一样，感知其结构内部的操作，也不用调用filp，随意的读取和写入即可。<br>同时，假如我们读Hollis这个数据，读到了一半，还剩下“is”没有读完，我们可以调用discardReadBytes方法将指针移位，为可写区域增加空间，如下所示：<br><img src="/assets/post/netty-useful-doc-8.png" alt="image.png"></p>
<h3 id="多种ByteBuf实现"><a href="#多种ByteBuf实现" class="headerlink" title="多种ByteBuf实现"></a>多种ByteBuf实现</h3><p>Netty根据不同的场景，有不同的ByteBuf实现，主要的几种分别是：Pooled，UnPooled，Direct，Heap，列表格如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Pooled</th>
<th>UnPooled</th>
</tr>
</thead>
<tbody><tr>
<td>HeapByteBuf</td>
<td>业务处理使用+高并发</td>
<td>业务处理使用+正常流量</td>
</tr>
<tr>
<td>DireactByteBuf</td>
<td>Socket相关操作使用+高并发</td>
<td>Socket相关操作使用+正常流量</td>
</tr>
</tbody></table>
<p>当然Netty中的Buffer性能相比于Java NIO的Buffer也更强，譬如我们熟知的Zero-Copy等，这个我们放到性能篇中剖析</p>
<h2 id="多种序列化方案"><a href="#多种序列化方案" class="headerlink" title="多种序列化方案"></a>多种序列化方案</h2><p>在网络编程中，是一定少不了序列化的，当我们在内存中形成对象之后，需要将对象转换为字节流通过Socket输出到网络中，同时接收端还需要通过Socket接收到字节流之后将字节转为内存中的对象，但是我们知道，Java原生的序列化方案不仅耗时长，而且转化出来的字节，占用内存也大，导致网络的吞吐量很高，同时，它也无法跨语言。所以，对于网络编程来讲，我们亟需要通过其他优秀的序列化方案进行网络传输。<br>Netty内置了很多序列化方案，如比较著名的Google的ProtoBuf，Netty就通过了io.netty.handler.codec.protobuf包下的类对其进行了支持。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a target="_blank" rel="noopener" href="https://netty.io/3.8/guide/#preface.2">Netty Doc</a></li>
<li><a target="_blank" rel="noopener" href="https://stream.nosdn.127.net/kids/1625672349182/Netty%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf">Netty权威指南</a></li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-01-10</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Netty/" title="Netty">Netty </a><i class="fa fa-star"></i><a class="tag" href="/categories/面试经验/" title="面试经验">面试经验 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://wxxlamp.cn/2023/01/10/netty-useful-doc/,王星星的魔灯,Netty可用性剖析,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/01/22/my-2023/" title="我的2022">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/01/06/teacher_note_4_it/" title="高中信息技术面试笔记">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false,
  verify:false|| false,
  app_id:'VzGOJC7bFNXeYUEicbM4nOT2-gzGzoHsz',
  app_key:'T3VwGNzVqiWepoUHUQMnh8tP',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>