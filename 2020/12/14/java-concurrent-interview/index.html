<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Core"><title>Java并发常见面试题 · 王星星的魔灯</title><meta name="description" content="珍惜每一天

以下只针对Java岗。来源主要是牛客的Java实习面经。下面的回答直接背就可以，需要一定的Java基础和并发基础，适合春招实习的同学，但是我会在每个问题下把有助于理解的博客贴出来。如果发现有问题欢迎私聊我或留言我会在下面更新

基本概念1. 说下线程安全需要保证的几个基本特性


阿里"><meta name="keywords" content="极限博客,极限Blog,博客,极限"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">王星星的魔灯</a></h3><div class="description"><p>心之所愿，无事不成。<br> Nothing is impossible to a willing heart.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/mrcore"><i class="fa fa-github"></i></a></li><li><a href="mailto:x@jixian.io"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY="><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com/people/"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"> <span>© 2017 - 2020 </span><i class="fa fa-star"></i><span> Core</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><a href="https://github.com/mrcore/hexo-theme-Anatole-Core" target="_blank">Anatole-Core  </a></div><div class="beian"><a href="http://www.beian.miit.gov.cn/" target="_blank">粤ICP备15011643号</a><span style="height:10px;margin-left: 10px;">|</span><img src="/images/gongan.png" style="height:10px;margin-left: 10px;position: relative;top: 1px;"><span style="margin-left: 2px;">粤公网安备 44030402003967号</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/guestbook">留言</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Java并发常见面试题</a></h3></div><div class="post-content"><p><strong>珍惜每一天</strong></p>
<blockquote>
<p>以下只针对Java岗。来源主要是<a target="_blank" rel="noopener" href="https://www.nowcoder.com/">牛客</a>的Java实习面经。下面的回答直接背就可以，需要一定的Java基础和并发基础，适合春招实习的同学，但是我会在每个问题下把有助于理解的博客贴出来。如果发现有问题欢迎私聊我或留言我会在下面更新</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h4 id="1-说下线程安全需要保证的几个基本特性"><a href="#1-说下线程安全需要保证的几个基本特性" class="headerlink" title="1. 说下线程安全需要保证的几个基本特性"></a>1. 说下线程安全需要保证的几个基本特性</h4><a id="more"></a>

<blockquote>
<p>阿里19年秋招本科</p>
</blockquote>
<ol>
<li><p><strong>原子性</strong>：线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，就会发生原子性问题。因为线程在执行一个读改写操作时，在执行完读改之后，时间片耗完，就会被要求放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在<strong>原子性问题</strong>。 </p>
<p><strong>实现</strong>：<code>synchronized</code>其实底层就是使用<code>monitorenter</code>和<code>monitorexit</code>实现的，在Java中可以使用<code>synchronized</code>来保证方法和代码块内的操作是原子性的。 </p>
</li>
<li><p><strong>有序性</strong>：除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如<code>load-&gt;add-&gt;save</code>有可能被优化成<code>load-&gt;save-&gt;add</code>。这就是<strong>有序性问题</strong>。 </p>
<p><strong>实现</strong>：<code>volatile</code>关键字会禁止指令重排。<code>synchronized</code>关键字保证同一时刻只允许一条线程操作 </p>
</li>
<li><p><strong>可见性</strong>：顾名思义，指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。即本地内存一致性问题(<em>本地内存指的是虚拟机栈</em>)。要保证在并发场景下程序运行结果和程序员的预期是一样的。</p>
<p><strong>实现</strong>：<code>volatile</code>,<code>synchronized</code>和<code>final</code>三个关键字实现可见性 </p>
</li>
</ol>
<p>这三个基本特性通过JMM来保证.</p>
<h4 id="2-多线程编程的好处是什么"><a href="#2-多线程编程的好处是什么" class="headerlink" title="2. 多线程编程的好处是什么"></a>2. 多线程编程的好处是什么</h4><blockquote>
<p>三七互娱19年春招</p>
</blockquote>
<p> 充分利用并发</p>
<ul>
<li><strong>从计算机底层来说</strong>， 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程 </li>
<li><strong>从当代互联网发展趋势来说</strong>，现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能</li>
<li><strong>对于单核来说</strong>，多线程主要是为了提高 CPU 和 IO 设备的综合利用率</li>
<li><strong>对于多核来说:</strong> 多线程主要是为了提高 CPU 利用率 </li>
</ul>
<p>但是多线程编程也会有弊端： 内存泄漏、上下文切换、死锁以及共享资源的修改值和预期不一样</p>
<h4 id="3-多线程和单线程的区别"><a href="#3-多线程和单线程的区别" class="headerlink" title="3. 多线程和单线程的区别"></a>3. 多线程和单线程的区别</h4><p>线程是CPU调度和分派的基本单位，多线程编程的目的，就是”<strong>最大限度地利用CPU资源</strong>“,当某一线程的处理不需要占用CPU而只和I/O,OEMBIOS等资源打交道时,让需要占用CPU资源的其它线程有机会获得CPU资源，这就是多线程最直观的好处</p>
<p>同时，多线程可发挥多核处理器的优势</p>
<p>还有就是使得建模和编程更加简单</p>
<p> <strong>一个数据集进行排序，使用单线程还是多线程处理，他们的优劣?</strong></p>
<blockquote>
<p>三七互娱19年春招</p>
</blockquote>
<p>确定该排序是IO密集型还是计算密集型，如果是IO密集型则多线程，如果是计算密集型则没太大作用。当然，如果是多核CPU的话，一定要是多线程</p>
<h4 id="4-多进程和多线程的区别"><a href="#4-多进程和多线程的区别" class="headerlink" title="4. 多进程和多线程的区别"></a>4. 多进程和多线程的区别</h4><blockquote>
<p>网易19年秋招本科</p>
</blockquote>
<ol>
<li>进程间除了IPC通信以外一般不会相互影响；但是一个线程挂掉就会影响整个进程</li>
<li>进程创建销毁比线程复杂</li>
<li>进程之间切换开销大，线程切换简单（对于需要频繁切换的，需要用到多线程）</li>
</ol>
<h4 id="5-进程和线程的区别"><a href="#5-进程和线程的区别" class="headerlink" title="5. 进程和线程的区别"></a>5. 进程和线程的区别</h4><p><strong>不要背书上概念，有实现过吗</strong></p>
<blockquote>
<p>滴滴19年秋招，网易19年秋招本科，瓜子二手车19年秋招本科</p>
</blockquote>
<p><strong>进程</strong>是系统进行<strong>资源分配和保护</strong>的基本单位，<strong>线程</strong>是<strong>处理器调度和分派</strong>的基本单位</p>
<ul>
<li><p>进程具有一个独立的执行环境。 进程是程序在计算机上的一次执行活动 。常情况下，进程拥有一个完整的、私有的基本运行资源集合。特别地，每个进程都有自己的内存空间。进程往往被看作是程序或应用的代名词，然而，用户看到的一个单独的应用程序实际上可能是一组相互协作的进程集合</p>
</li>
<li><p>线程有时也被称为轻量级的进程。进程和线程都提供了一个执行环境，但创建一个新的线程比创建一个新的进程需要的资源要少。线程是在进程中存在的，每个进程最少有一个线程。线程共享进程的资源，包括内存和打开的文件</p>
</li>
</ul>
<h4 id="6-一个线程修改值，另外一个线程能看到修改吗"><a href="#6-一个线程修改值，另外一个线程能看到修改吗" class="headerlink" title="6. 一个线程修改值，另外一个线程能看到修改吗"></a>6. 一个线程修改值，另外一个线程能看到修改吗</h4><blockquote>
<p>滴滴19年秋招</p>
</blockquote>
<p>正常情况下，线程修改的值是工作内存的值，此时别的线程是看不到的。我们可以通过volatile立刻刷新该值到主内存中，这样另外的线程就可以看到值了</p>
<p>对于volatile：</p>
<ul>
<li>读操作时JMM会把工作内存中对应的值设为无效，要求线程从主内存中读取数据</li>
<li>写操作时JMM会把工作内存中对应的数据刷新到主内存中，这种情况下，其它线程就可以读取变量的最新值 </li>
</ul>
<h4 id="7-Happens-before"><a href="#7-Happens-before" class="headerlink" title="7. Happens-before"></a>7. Happens-before</h4><blockquote>
<p>阿里19年秋招</p>
</blockquote>
<p>JSR-133规定：</p>
<ul>
<li><p>Happens-before可以理解为一种内存模型，它相对于JMM来说更松散。</p>
</li>
<li><p>如果一个动作 happens-before 另一个动作，则第一个对第二个可见，且第一个排在第二个之前。必须强调的是，两个动作之间存在 happens-before 关系并不意味着这些动作 在 Java 中必须以这种顺序发生。happens-before 关系主要用于强调两个有冲突的动作之间的顺序，以及定义数据争用的发生时机</p>
</li>
</ul>
<p>主要有：</p>
<ul>
<li>某个线程中的每个动作都 <em>happens-before</em> 该线程中该动作后面的动作</li>
<li>某个管程上的 unlock 动作 <em>happens-before</em> 同一个管程上后续的 lock 动作</li>
<li>对某个 volatile 字段的写操作 <em>happens-before</em> 每个后续对该 volatile 字段的读操作</li>
<li>在某个线程对象上调用 start()方法 <em>happens-before</em> 该启动了的线程中的任意动作</li>
<li>某个线程中的所有动作 <em>happens-before</em> 任意其它线程成功从该线程对象上的join()中返回</li>
<li>如果某个动作 a <em>happens-before</em> 动作 b，且 b <em>happens-before</em> 动作 c，则有 a  happens-before c</li>
<li>对象的构造函数执行的结束 <em>happens-before</em> finalize()方法</li>
<li>对线程interrupt()方法的调用 <em>happens-before</em> 被中断线程的代码检测到中断事件的发生 </li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility">Happens-Before</a></p>
<h4 id="8-JMM内存可见性"><a href="#8-JMM内存可见性" class="headerlink" title="8. JMM内存可见性"></a>8. JMM内存可见性</h4><blockquote>
<p>pdd19年实习</p>
</blockquote>
<p>JMM通过volatile保证内存可见性</p>
<ol>
<li>线程终止的时候，工作内存的值会强行刷新到主内存</li>
<li>线程释放锁时，工作内存的值会强行刷新到主内存</li>
<li>使用synchronized和final也可以保证可见性</li>
</ol>
<h4 id="9-可见性干了个什么"><a href="#9-可见性干了个什么" class="headerlink" title="9. 可见性干了个什么"></a>9. 可见性干了个什么</h4><blockquote>
<p>阿里19年秋招</p>
</blockquote>
<p>当多个线程访问同一个变量时，一个线程修改了这个变    量的值，其他线程能够立即看得到修改的值</p>
<h4 id="10-问一下Java的内存模型"><a href="#10-问一下Java的内存模型" class="headerlink" title="10. 问一下Java的内存模型"></a>10. 问一下Java的内存模型</h4><blockquote>
<p>阿里19年秋招本科，滴滴19年秋招本科</p>
</blockquote>
<ul>
<li><p>JMM是在JSR-133中规定的一系列保证Java正确并发的准则模型，给定一个程序和该程序的一串执行轨迹，<em>内存模型</em>描述了该执行轨迹是否是该程序的一次合法执行。内存模型的一个高级、非正式的概述显示其是一组规则，规定了一个线程的写操作何时会对另一个线程可见。表现在Java代码中就是synchronized，volatile，final，JUC等的语义</p>
</li>
<li><p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>
</li>
<li><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。JMM就作用于<strong>工作内存和主存之间数据同步</strong>过程。他规定了如何做数据同步以及什么时候做数据同步</p>
</li>
<li><p>内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。</p>
</li>
</ul>
<h4 id="11-多线程如何实现主存同步的"><a href="#11-多线程如何实现主存同步的" class="headerlink" title="11. 多线程如何实现主存同步的"></a>11. 多线程如何实现主存同步的</h4><blockquote>
<p>滴滴19年本科</p>
</blockquote>
<p>一个是JMM可见性</p>
<ul>
<li>线程终止的时候，工作内存的值会强行刷新到主内存</li>
<li>线程释放锁时，工作内存的值会强行刷新到主内存</li>
<li>使用Volatile也可以保证可见性</li>
<li>因为final在初始化完成后具有不变性，这也是JMM可见性的语义</li>
</ul>
<p>一个是缓存一致性</p>
<ul>
<li>MESI</li>
<li>总线加#LOCK锁</li>
</ul>
<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h4 id="1-线程是不是越多越好，设置数量的考虑"><a href="#1-线程是不是越多越好，设置数量的考虑" class="headerlink" title="1. 线程是不是越多越好，设置数量的考虑"></a>1. 线程是不是越多越好，设置数量的考虑</h4><blockquote>
<p>京东19年秋招</p>
</blockquote>
<p>当然不是越多越好</p>
<ol>
<li>线程的创建和切换要消耗很多时间和资源（线程池）</li>
<li>CPU在线程间频繁的上下文切换也需要消耗时间和资源</li>
<li>每个线程也需要消耗一定的内存空间</li>
<li>服务器CPU核数有限，同时并发的线程数是有限的</li>
</ol>
<p>公式：<br>$$<br>thread_n = (wait_t + compute_t) \div compute_t \times CPU_n<br>$$</p>
<ul>
<li>I/O 密集型为：CPU*2</li>
<li>计算密集型为：CPU + 1</li>
</ul>
<h4 id="2-多线程是如何控制同步的"><a href="#2-多线程是如何控制同步的" class="headerlink" title="2. 多线程是如何控制同步的"></a>2. 多线程是如何控制同步的</h4><blockquote>
<p>腾讯19年秋招</p>
</blockquote>
<p>通过synchronized，volatile，ThreadLocal，J.U.C来控制同步，下面的问题有详细说明</p>
<h4 id="3-ThreadLocal的内部实现"><a href="#3-ThreadLocal的内部实现" class="headerlink" title="3. ThreadLocal的内部实现"></a>3. <code>ThreadLocal</code>的内部实现</h4><blockquote>
<p>头条19年实习，阿里19年秋招</p>
</blockquote>
<ol>
<li><p><code>ThreadLocal</code>提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。<code>ThreadLocal</code> 变量通常被<code>private static</code>修饰。当一个线程结束时，它所使用的所有 <code>ThreadLocal </code>相对的实例副本都可被回收。</p>
</li>
<li><p>Spring的事物和服务器请求均用到了<code>ThreadLocal</code>，总的来说<code>ThreadLocal</code>可以非常完美的满足如下两种场景：</p>
<ul>
<li>每个线程需要有自己单独的实例 <em>(可通过在线程内部构件一个实例来实现)</em></li>
<li>实例需要在多个方法中共享，但不希望被多线程共享 <em>(可通过<code>static</code>或者通过方法间的参数传递来实现)</em></li>
</ul>
</li>
<li><p>每个<code>Thread</code>中都存有一个<code>ThreadLocalMap</code>字段，它是<code>ThreadLocal</code>的内部类，每个线程实例都有自己的<code>ThreadLocalMap</code>。<code>ThreadLocalMap</code>实例的key为<code>ThreadLocal</code>，value为<code>T</code>类型的值。在多线程调用中，会存在和线程实例相同的<code>ThreadLocalMap</code>，但只有一个<code>ThreadLocal</code>。这三者的调用路径为：</p>
</li>
</ol>
<p>$$<br>Thread\rightarrow ThreadLocal\rightarrow ThreadLocalMap<br>$$</p>
<ol start="3">
<li><p><strong>读取实例</strong>：线程首先通过<code>getMap((Thread)t)</code>方法获取自身的<code>ThreadLocalMap</code>，然后通过<code>map.getEntry((TreadLocal)this)</code>方法获取该<code>ThreadLocal</code>在当前线程的<code>ThreadLocalMap</code>中对应的<code>Entry</code>，最后从<code>Entry</code>中取出值即为所需访问的本线程对应的实例。如果<code>ThreadLocalMap</code>或者<code>Entry</code>为空，则通过 <code>setInitialValue()</code>-&gt;<code>createMap(thread,value)</code>方法设置初始值，此时的<code>value</code>则是<code>initialValue</code>的返回值。</p>
<p><em>PS：使用<code>setInitialValue()</code>而不是<code>set(T vlaue)</code>是为了防止用户覆盖<code>set(T value)</code></em></p>
</li>
<li><p><strong>设置实例</strong>：除了<code>initialValue()</code>初始化的设置实例和私有的<code>setInitiValue()</code>，我们主要用<code>set(T value)</code>来设置实例。该方法先获取该线程的<code>ThreadLocalMap</code>对象，然后直接将<code>ThreadLocal</code>对象与目标实例的映射添加进<code>ThreadLocalMap</code>中。当然，如果映射已经存在，就直接覆盖。另外，如果获取到的<code>ThreadLocalMap</code>为  null，则先创建该<code>ThreadLocalMap</code>对象。</p>
</li>
<li><p><strong>防止内存泄漏</strong>：<code>ThreadLocalMap</code>的<code>Entry</code>对key为<code>ThreadLocal</code>的引用为弱引用，避免了<code>ThreadLocal</code>对象无法被回收的问题，但是当<code>ThreadLocal</code>被回收后为<code>null</code>，此时<code>Entry</code>无法被GC。所以针对该问题，<code>ThreadLocalMap</code>的<code>set(key, vlaue)</code>方法中，通过<code>replaceStaleEntry</code>方法将所有键为<code>null</code>的<code>Entry</code>的值设置为<code>null</code>从而使得该值可被回收。另外，会在<code>rehash</code>方法中通过<code>expungeStaleEntry</code>方法将键和值为<code>null</code>的<code>Entry</code>设置为<code>null</code>从而使得该<code>Entry</code>可被回收。通过这种方式<code>ThreadLocal</code>可防止内存泄漏。 </p>
</li>
</ol>
<p>参考文章：<a target="_blank" rel="noopener" href="http://www.jasongj.com/java/threadlocal/">正确理解Thread Local的原理与使用场景</a>、<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">JDK1.8 source code</a></p>
<h4 id="4-线程之间的交互方式有哪些？有没有线程交互的封装类"><a href="#4-线程之间的交互方式有哪些？有没有线程交互的封装类" class="headerlink" title="4. 线程之间的交互方式有哪些？有没有线程交互的封装类"></a>4. 线程之间的交互方式有哪些？有没有线程交互的封装类</h4><blockquote>
<p>华为19年社招</p>
</blockquote>
<ol>
<li>通过<code>notify()</code>/<code>notifyAll()</code>：唤醒在此对象监视器锁上被block的（所有）线程，之后再次竞争锁</li>
<li>通过<code>join()</code>：A线程执行b.join，那么A线程等待，b线程先执行。该方法通过<code>wait()</code>实现</li>
<li>通过<code>interrupt()</code>：将调用该方法的线程置为中断状态，通过<code>isInterrupt()</code>这个标记来退出此线程</li>
<li>通过<code>yield()</code>：使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。CPU会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了</li>
<li>线程通过<code>wait()</code>和<code>sleep()</code>睡眠（这两个方法的作用只是大概一样），然后CPU去调度其他线程</li>
</ol>
<p>线程交互封装类：不懂</p>
<h4 id="5-谈谈线程的基本状态，wait-sleep-yield方法的区别"><a href="#5-谈谈线程的基本状态，wait-sleep-yield方法的区别" class="headerlink" title="5. 谈谈线程的基本状态，wait,sleep,yield方法的区别"></a>5. 谈谈线程的基本状态，<code>wait</code>,<code>sleep</code>,<code>yield</code>方法的区别</h4><blockquote>
<p>华为19年社招</p>
</blockquote>
<p>线程共有六种基本状态，分别是<code>NEW</code>，<code>RUNNABLE</code>，<code>BLOCKED</code>，<code>WAITING</code>，<code>TIMED_WAITING</code>，<code>TERMINATED</code></p>
<ul>
<li><code>NEW</code>：线程被new出来，但是没有调用start方法</li>
<li><code>RUNNABLE</code>：分为运行态和就绪态。就绪态即在等待一些资源如CPU</li>
<li><code>BLOCKED</code>：等待monitor的锁，一般是要进入<code>synchronized</code>块或者方法中的线程。这对应着<code>synchronized</code>中对象的<code>MonitorObject</code>的<code>_EntryList</code>队列</li>
<li><code>WAITING</code>：当线程调用了<code>Object.wait()</code>,<code>Thread.join()</code>或者<code>LockSupport.park()</code>方法时，进入等待状态，直到使用<code>notify()</code>/<code>notifyAll()</code>,<code>LockSupport.unpark()</code>或者调用方法的线程结束</li>
<li><code>TIMED_WAITING</code>：是一种特殊的等待状态，当线程调用了<code>Thread.sleep(long)</code>,<code>Object.wait(long)</code>, <code>Thread.join(long)</code>, <code>LockSupport.parkNanos(long)</code>或者<code>LockSupport.parkUntil(long)</code>方法时，进入超时等待状态</li>
<li><code>TERMINATED</code>：线程已经完成执行，进入结束状态</li>
</ul>
<p><code>Object.wait()</code>和<code>Thread.sleep()</code>，都可以让线程进入阻塞状态</p>
<ol>
<li><code>sleep()</code>方法使执行中的线程主动让出CPU，进入<code>TIMED_WAITING</code>状态，但是不会释放对象锁，在sleep指定时间后CPU便会到可执行状态<code>RUNNABLE</code>。注意，runnable并不表示线程一定可以获得CPU。需要等待被CPU调度后进入运行</li>
<li><code>wait()</code>方法使执行中的线程主动让出CPU，会<strong>放弃对象锁</strong>，进入<code>WAITING</code>状态，只有调用了<code>notify()</code> /<code>notifyAll()</code>方法，才会从等待队列中被移出，重新获取锁之后，便可再次变成可执行状态(runnable)。 sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用。同时，wait和notify组成经典的等待唤醒机制才是有意义的，单独使用作用不大。wait(long)是没有通知超时返回的方法，此方法单独使用，和sleep效果一样</li>
<li><code>yield()</code>方法使当前线程从执行状态（运行状态）变为可执行态（就绪状态），总体上来说该线程一直是在<code>RUNNABLE</code>状态。CPU会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了</li>
</ol>
<h4 id="6-Java实现线程同步有哪些方式"><a href="#6-Java实现线程同步有哪些方式" class="headerlink" title="6. Java实现线程同步有哪些方式"></a>6. Java实现线程同步有哪些方式</h4><blockquote>
<p>bigo19年秋招本科</p>
</blockquote>
<p>线程同步就是两个或两个以上的线程在运行过程中协同步调，按预定的先后次序运行。比如 A 任务的运行依赖于 B 任务产生的数据。如消费者线程需要依靠生产者线程生产消息后，消费者线程才能消费消息</p>
<ol>
<li>实现线程同步需要锁，一般有两种锁<ul>
<li>synchronized+wait/notify</li>
<li>ReentrantLock+Condition</li>
</ul>
</li>
<li>或者采用Semaphore</li>
</ol>
<h4 id="7-创建线程的各种方式"><a href="#7-创建线程的各种方式" class="headerlink" title="7. 创建线程的各种方式"></a>7. 创建线程的各种方式</h4><ol>
<li>继承<code>Thread</code></li>
<li>实现<code>Runnable</code></li>
<li>通过<code>FutureTask</code>和<code>Callable</code></li>
<li>通过线程池</li>
</ol>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="1-线程池的概念，好处在哪"><a href="#1-线程池的概念，好处在哪" class="headerlink" title="1. 线程池的概念，好处在哪"></a>1. 线程池的概念，好处在哪</h4><blockquote>
<p>网易19年秋招本科</p>
</blockquote>
<p>线程池是池化技术的一种应用，包括数据库连接池，HTTP连接池都是利用了线程池技术。<strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。 </p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="2-线程池种类，拒绝策略，任务执行流程"><a href="#2-线程池种类，拒绝策略，任务执行流程" class="headerlink" title="2. 线程池种类，拒绝策略，任务执行流程"></a>2. 线程池种类，拒绝策略，任务执行流程</h4><blockquote>
<p>小米19年秋招本科，滴滴19年秋招本科</p>
</blockquote>
<p>狭义上来说，线程池的种类是指有<code>Executors</code>创建的并且底层都是由<code>ThreadPoolExecutor</code>实现的四种线程，分别是：</p>
<ol>
<li><code>newFixedThreadPool(int nThread)</code>： 被称为可重用固定线程数的线程池。采用 <code>ThreadPoolExecutor(nThread,nThread,0L,TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;());</code> 从这里我们可以看出来线程池的核心线程和最大线程数是相同的。同时当任务超过线程数时，其等待队列是无限长的(<code>INTEGER.MAX_VALUE</code>)，此时当任务过多时会产生内存溢出。<strong>适用于任务量比较固定但耗时长的任务</strong></li>
</ol>
<ol start="2">
<li><p><code>newSingleThreadExecutor</code>：采用 <code>new FinalizableDelegatedExecutorService    (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()) );</code> 可以看出来，核心线程和最大线程数都是1，同时等待队列也是无限长的。至于<code>FinalizableDlegatedExecutorService()</code>，它继承了一个关于<code>ExecutorService</code>的wrapper类，被包装之后只能调用<code>ExecutorService</code>的方法，但是调用不了<code>ThreadPoolExecutor</code>类的方法。<strong>适用于一个任务一个任务执行的场景</strong></p>
</li>
<li><p><code>newCacheThreadPool</code>：采用 <code>new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);</code> 可以看出，核心线程是0，最大线程是<code>MAX_VALUE</code>，<code>KeepAlive</code>是60s，线程采用的队列是同步队列。当有新任务到来，则插入到<code>SynchronousQueue</code>中，由于<code>SynchronousQueue</code>是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过60s，则该线程会被销毁。<strong>适用于执行很多短期异步的小程序或者负载较轻的服务器</strong></p>
</li>
<li><p><code>newScheduledThreadPool</code>: 采用<code>new ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());</code> 可以看出，最大线程为<code>Integer.MAX_VALUE</code>，存活时间无限制。等待队列为<code>DelayedWorkQueue</code>，是<code>ScheduledThreadPoolExecutor</code>的内部类，它是一种按照超时时间排序的队列结构，由堆实现。当运行的线程数没有达到<code>corePoolSize</code>的时候，就新建线程去<code>DelayedWorkQueue</code>中取<code>ScheduledFutureTask</code>然后才去执行任务，否则就把任务添加到<code>DelayedWorkQueue</code>，<code>DelayedWorkQueue</code>会将任务排序，按新建一个非核心线程顺序执行，执行完线程就回收，然后循环。任务队列采用的<code>DelayedWorkQueue</code>是个无界的队列，延时执行队列任务。<strong>适用于执行定时任务和具体固定周期的重复任务</strong></p>
</li>
</ol>
<p>但其实还有第五种：<code>newWorkStealingPool</code>： 创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行，<strong>适用于大耗时的操作，可以并行来执行</strong> </p>
<p><strong>线程池的拒绝状态</strong> 一般有四种，分别是1. 丢弃任务并抛出<code>RejectedExecutionException</code>异常；2. 也是丢弃任务，但是不抛出异常；3. 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）；4. 由调用线程处理该任务</p>
<p><strong>任务执行流程</strong></p>
<blockquote>
<p>阿里19年实习，字节跳动19年秋招本科</p>
</blockquote>
<p>整个流程为：<br>$$<br>execute() \rightarrow addWorker()\rightarrow Thread.start() \rightarrow runWorker() \rightarrow getTask() \rightarrow processWorkerExit()<br>$$<br>四种线程池都是通过<code>ThreadPoolExecutor</code>的构造方法实现的，执行任务流程主要是说的该类下的主要方法的具体原理：</p>
<ul>
<li><p><code>ThreadPoolExecutor</code>类中有一个<code>AtomicInteger</code>类型的<code>final</code>变量<code>ctl</code>，该变量有两重意思，一个是表示工作的线程数，另一个是表示当前线程池的五种状态。其实<code>Integer</code>类型，共32位，高3位保存runState，低29位保存workerCount </p>
</li>
<li><p>对于<code>execute(Runnable)</code>来说：</p>
<ul>
<li>整体过程是：先提交任务，如果<code>workerCount</code>&lt;<code>corePoolSize</code>，则新建线程并执行该任务；如果<code> workerCount</code> &gt;= <code>corePoolSize</code> &amp;&amp;<code>阻塞队列未满</code>，则把任务添加到阻塞队列中；如果<code>workerCount</code> &gt;= <code>corePoolSize</code> &amp;&amp; <code>workerCount</code> &lt; <code>maximumPoolSize </code>&amp;&amp;<code>阻塞队列已满</code>，则创建线程并执行该任务；如果 <code>workerCount</code> &gt;=  <code>maximumPoolSize</code>，则拒绝该任务</li>
<li>从源码上看：首先获得<code>ctl</code>的值，如果<code>workerCount</code>&lt;<code>corePoolSize</code>，则通过<code>addWorker</code>提交任务。如果提交任务失败*(有两个原因，一个是线程数超过最大值，另外一个是线程状态不是Running，这也是为何后面要recheck的原因)*，则重新获得<code>ctl</code>的值，然后判断线程池的状态，如果为<code>Running</code>则把任务插入队列。再次获得<code>ctl</code>对线程数目和线程池状态进行<code>recheck</code>，如果此时线程池状态不是<code>Running</code>则把已经插入队列的任务移出，并调用拒绝策略，如果此时线程池中线程数目为0，则通过<code>addWorker</code>新建线程*(此处保证线程池最少有一个线程执行任务)*。之后的情况说明队列已满并且<code>workCount</code>&gt;<code>corePoolSize</code>，此时再次调用<code>addWorker</code>提交任务，提交失败，则拒绝该任务</li>
</ul>
</li>
<li><p>对于<code>addWorker(Runnable,Boolean)</code>来说，从源码来看，分为3部分：</p>
<ul>
<li>检查是否<code>runState</code>&gt;=<code>Shutdown</code>&amp;&amp;(<code>rs == SHUTDOWN</code>, <code>firsTask为空</code>,<code>阻塞队列不为空</code>都成立)，否则返回false</li>
<li>通过CAS增加线程数（并不是实际增加，只是通过增加<code>ctl</code>）。其中，<code>break retry</code>说明增加成功，<code>continue retry</code>说明runState改变，重新开始goto和循环</li>
<li>真正创建新的worker，开始新线程(worker实现了Runnable，也是线程)。创建worker的时候需要通过<code>ReentrantLock</code>加锁，创建成功后(<code>workers.add(worker)</code>)设置线程池的大小<code>largestPoolSize</code>，之后释放锁，然后启动线程，并执行任务</li>
</ul>
</li>
</ul>
<ul>
<li><p>对于<code>Worker</code>类来说，它是<code>ThreadPoolExecutor</code>的内部类，实现了<code>Runnable</code>接口，继承了<code>AQS</code>，同时线程池底层就是<code>HashSet&lt;Worker&gt;</code>这个类</p>
<ul>
<li>其有两个重要的变量<code>firstTask</code>保存了要执行的任务，<code>thread</code>通过构造方法中的 <code>getThreadFactory().newThread(this)</code>来新建一个线程。所以<code>t.start()</code>就等于说调用了<code>worker.run()</code>，而<code>worker.run()</code>又调用了<code>worker.runWorker()</code>方法</li>
<li><code>Worker</code>继承自AQS，用于判断线程是否空闲以及是否可以被中断。为什么不用<code>ReentrantLock</code>呢？通过<code>Worker</code>的<code>tryAcquire</code>可以看出该锁是不可重入的，但是<code>ReentrantLock</code>却是可重入锁。之所以设置为不可重入锁，主要是不希望当执行譬如<code>setCorePoolSize()</code>这样的线程池控制方法时中断正在执行任务的线程*(这种线程池控制方法还有shutdown()等，会调用interruptIdleWorkers()方法来中断空闲的线程，interruptIdleWorkers()方法会使用tryLock()方法来判断线程池中的线程是否是空闲状态，而tryLock()又会通过tryAcquire()来判断线程池中的线程是否是空闲状态。查看源码可得用到了AQS的方法，这也能解释为什么构造方法将state设为-1，即为了禁止在执行任务前对线程进行中断  )*，然后重新获取锁。如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断</li>
</ul>
</li>
<li><p>对于<code>runWorker()</code>来说：</p>
<ul>
<li>先通过while循环不断通过<code>getTask()</code>去获得任务</li>
<li>如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态</li>
<li>调用<code>task.run()</code>执行任务</li>
<li>如果task为null则跳出循环，执行<code>processWorkerExit()</code>方法</li>
<li><code>runWorker</code>方法执行完毕，也代表着Worker中的<code>run</code>方法执行完毕，销毁线程</li>
<li>注意两个钩子<code>beforeExecute()</code>和<code>afterExecute()</code>，这两个类是空的，留给子类实现</li>
</ul>
</li>
<li><p>对于<code>getTask()</code>来说，它从阻塞队列中获取任务。通过workQueue.poll和take来获取任务，前者是如果在keepAliveTime时间内没有获取到任务，则返回null，后者是一直阻塞直到获取任务</p>
</li>
<li><p>而最后一步<code>processWorkerExit()</code> 为垂死的Worker做清理和记录。仅从工作线程调用。除非<code>completedAbruptly</code>被设置，否则假定workerCount已经被调整以考虑退出。此方法从工作集中移除线程，如果线程因用户任务异常而退出，或者运行的工作线程小于corePoolSize，或者队列非空但没有工作线程，则可能终止池或替换工作线程 </p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/warehouse/p/10720781.html">线程池原理</a></p>
<h4 id="4-线程池的工作原理，核心线程数和最大线程数什么时候用到"><a href="#4-线程池的工作原理，核心线程数和最大线程数什么时候用到" class="headerlink" title="4. 线程池的工作原理，核心线程数和最大线程数什么时候用到"></a>4. 线程池的工作原理，核心线程数和最大线程数什么时候用到</h4><blockquote>
<p>阿里19年秋招</p>
</blockquote>
<p>整个线程池通过<code>ThreadPoolExecutor</code>类中的一系列方法调用：<br>$$<br>execute() \rightarrow addWorker()\rightarrow Thread.start() \rightarrow runWorker() \rightarrow getTask() \rightarrow processWorkerExit()<br>$$<br>当新增一个任务时，会先观察是否小于核心线程数，如果小于核心线程数，则直接执行<code>addWorker()</code>方法，大于核心线程数且阻塞队列已满，并且当前线程小于最大线程数，则添加该任务并执行。</p>
<h4 id="5-线程池中的各种接口"><a href="#5-线程池中的各种接口" class="headerlink" title="5. 线程池中的各种接口"></a>5. 线程池中的各种接口</h4><blockquote>
<p>三七互娱19年春招</p>
</blockquote>
<p>从<code>executor</code>到<code>executorService</code>,<code>ThreadPoolExecutor</code>,<code>Executors</code>,谈到了里面都有哪些方法？ </p>
<ol>
<li>接口<code>Executor</code>： 它是一个顶层接口，在它里面只声明了一个方法<code>void execute(Runnable)</code>，从字面意思可以理解，就是用来执行传进去的任务</li>
<li>继承1的接口<code>ExecutorService</code>：提供了管理终止的方法，以及可为跟踪一个或多个异步任务执行状况而生成 <code>Future</code>的方法。增加了<code>shutDown()</code>，<code>shutDownNow()</code>，<code>invokeAll()</code>，<code>invokeAny()</code>和<code>submit()</code>等方法。如果需要支持即时关闭，也就是<code>shutDownNow()</code> 方法，则任务需要正确处理中断 实现了2的抽象类<code>AbstractExecutorService</code>：对2的一些主要方法进行了实现，但是没有实现<code>execute</code></li>
<li>继承了3的类<code>ThreadPoolExecutor</code>：该类有四种构造线程池的构造方法，线程池主要就说的是这个类</li>
<li>继承了4的类<code>ScheduledThreadPoolExecutor</code>：它实现了同样实现了<code>ExecutorService</code>接口的<code>ScheduledExecutorService</code>接口。该接口增加了<code>schedule</code>方法。调用<code>schedule</code>方法可以在指定的延时后执行一个<code>Runnable</code>或者<code>Callable</code>任务。<code>ScheduledExecutorService</code>接口还定义了按照指定时间间隔定期执行任务的<code>scheduleAtFixedRate()</code>方法和<code>scheduleWithFixedDelay()</code>方法 </li>
<li>类<code>Executors</code>：线程池中的工具类。该类中有四种构造线程池的方法，使用的是<code>ThreadPoolExecutor</code>的四种构造方法</li>
</ol>
<p><strong><code>ThreadPoolExecutor</code>的具体工作流程</strong><br>$$<br>execute() \rightarrow addWorker()\rightarrow Thread.start() \rightarrow runWorker() \rightarrow getTask() \rightarrow processWorkerExit()<br>$$</p>
<h4 id="6-线程池的参数怎么设置"><a href="#6-线程池的参数怎么设置" class="headerlink" title="6. 线程池的参数怎么设置"></a>6. 线程池的参数怎么设置</h4><p>设置线程池一般会通过<code>Executors</code>或者<code>ThreadPoolExecutor</code>，但是最终都调用了下面这个方法来设置线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span></span><br></pre></td></tr></table></figure>

<p>其中有7个参数，分别是</p>
<ol>
<li><code>corePoolSize</code>：核心线程数。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了<code>prestartAllCoreThreads()</code>或者<code>prestartCoreThread()</code>方法，在没有任务到来之前就创建<code>corePoolSize</code>个线程或者一个线程。当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。核心线程在<code>allowCoreThreadTimeout</code>被设置为true时会超时退出，默认情况下不会退出</li>
<li><code>maximumPoolSize</code>：最大线程池数。即当需要的线程数超过核心线程数并且任务等待队列已满时，此时线程池可以再创建一批线程来满足需求。但是创建后线程池中的线程数不能超过<code>maximumPoolSize</code></li>
</ol>
<p>当然也可以在创建完线程池之后通过<code>setCorePoolSize()</code>/<code>setMaximumPoolSize()</code>修改这些值</p>
<ol start="3">
<li><p><code>keepAliveTime</code>：当线程空闲时间达到<code>keepAliveTime</code>，该线程会退出，直到线程数量等于<code>corePoolSize</code>。如果<code>allowCoreThreadTimeout</code>设置为true，则所有线程均会退出直到线程数量为0</p>
</li>
<li><p><code>unit</code>：<code>keepAliveTime</code>的单位，有7种属性，分别是：<code>DAYS</code>,<code>HOURS</code>,<code>MINUTES</code>,<code>SECONDS</code>, <code>MILLISECONDS</code>, <code>MICROSECONDS</code>,<code>NANOSECONDS</code></p>
</li>
<li><p><code>workQueue</code>：任务缓存队列及排队策略。当任务超过<code>maximumPoolSize</code>后，回到<code>workQueue</code>中等待，它有如下三种取值：</p>
<ul>
<li><code>ArrayBlockingQueue</code>：基于数组的先进先出队列，此队列创建时必须指定大小</li>
<li><code>LinkedBlockingQueue</code>：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为<code>Integer.MAX_VALUE</code></li>
<li><code>synchronousQueue</code>：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</li>
</ul>
</li>
<li><p><code>threadFactory</code>：创建线程的工厂，这里可以统一创建线程以及规定线程的属性。推荐使用guava包</p>
</li>
<li><p><code>handler</code>：任务拒绝策略。 当线程池的任务缓存队列已满并且线程池中的线程数目达到<code>maximumPoolSize</code>，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略 ：</p>
<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>:丢弃任务并抛出<code>RejectedExecutionException</code>异常</li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛出异常</li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务.。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你<strong>不能任务丢弃任何一个任务请求的话</strong>，你可以选择这个策略。 </li>
</ul>
</li>
</ol>
<p><strong>参数设置</strong></p>
<ul>
<li><p><code>corePoolSize</code>：<br>$$<br>task_n * task_t<br>$$</p>
</li>
<li><p><code>queue</code>：<br>$$<br>corePoolSize_n \div task_t \times response_t<br>$$</p>
</li>
</ul>
<p><strong>如果请求超过了线程池的线程数会发生什么</strong></p>
<blockquote>
<p>腾讯19年秋招，滴滴19年秋招本科</p>
</blockquote>
<ul>
<li><p>当请求超过了线程池的核心线程数但不超过最大线程时时，会先检查请求队列是否满载，如果请求队列已满，则创建新的线程，如果不满，则把该任务加入请求队列</p>
</li>
<li><p>当请求线程超过最大线程时，则采用拒绝策略拒绝该任务</p>
</li>
</ul>
<h4 id="7-线程池有几种"><a href="#7-线程池有几种" class="headerlink" title="7. 线程池有几种"></a>7. 线程池有几种</h4><blockquote>
<p>oppo19年秋招本科</p>
</blockquote>
<p>常见的线程池有四种，分别是：</p>
<ul>
<li><code>newSingleThreadExecutor()</code>：只有一个线程处理，等待队列无限大，任务过多容易OOM，适合一个任务一个任务执行的场景</li>
<li><code>newCachedThreadPool()</code>：核心线程为0，最大线程数无限大，当线程过多时，容易OOM，适合执行很多短期异步的小程序</li>
<li><code>newFixedThreadExecutor()</code>：核心线程数和最大线程数相同，等待队列无限大，任务过多容易OOM，适合稳定数目的任务</li>
<li><code>newScheduledThreadPool()</code>：和其他三种有些不一样，继承了<code>ScheduledThreadPoolExecutor</code>，同时使用<code>DelayQueue</code>，该队列可以按时间远近进行排序。最大线程无限大，当线程过多时，容易OOM，适合做一些固定周期的任务</li>
</ul>
<p><strong>说一下线程池的几个重要的参数</strong></p>
<p><code>corePoolSize</code>,<code>maxmumPoolSize</code>,<code>keepAliveTime</code>,<code>unit</code>,<code>workQueue</code>,<code>threadFactory</code>,<code>handle</code></p>
<p><strong><code>newFixedThreadPool</code>这个线程池的初始化大小是怎么决定的</strong></p>
<ul>
<li>I\O密集，2*CPU</li>
<li>计算密集：CPU+1</li>
<li>公式：（等待时间+计算时间）/计算时间 * CPU</li>
</ul>
<h4 id="ScheduleThreadPool和Timer的区别"><a href="#ScheduleThreadPool和Timer的区别" class="headerlink" title="ScheduleThreadPool和Timer的区别"></a>ScheduleThreadPool和Timer的区别</h4><ol>
<li>Timer单线程，不能抛出异常，对系统时间敏感</li>
<li>ScheduleThreadPool多线程，能抛出异常，相对时间</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://www.ideabuffer.cn/2017/04/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AScheduledThreadPoolExecutor/">ScheduleThreadPool精讲</a></p>
<h4 id="8-自定义的线程池的实现"><a href="#8-自定义的线程池的实现" class="headerlink" title="8. 自定义的线程池的实现"></a>8. 自定义的线程池的实现</h4><blockquote>
<p>瓜子二手车19年秋招本科</p>
</blockquote>
<p>此处可以继承<code>ThreadPoolExecutor</code>，实现一个自定义的线程。实际考察的还是线程池的原理。我们需要知道，线程池中线程的复用主要是在<code>runWorker()</code>方法中的<code>while (task != null || (task = getTask()) != null)</code>循环决定</p>
<p>具体可以参考我的<a target="_blank" rel="noopener" href="https://github.com/stalern/MyConcurrent">Github</a></p>
<h4 id="9-SynchronousQueue到底可以存几个"><a href="#9-SynchronousQueue到底可以存几个" class="headerlink" title="9. SynchronousQueue到底可以存几个"></a>9. SynchronousQueue到底可以存几个</h4><blockquote>
<p>滴滴19年秋招本科</p>
</blockquote>
<p>因为它是一种同步队列，所以内部没有任何容量。仅在试图要取得元素时，该元素才存在。所以只能存一个</p>
<h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><h4 id="1-说一下死锁，写出来"><a href="#1-说一下死锁，写出来" class="headerlink" title="1. 说一下死锁，写出来"></a>1. 说一下死锁，写出来</h4><blockquote>
<p>小米19年秋招本科，联行科技19年秋招本科</p>
</blockquote>
<p>死锁是指两个或两个以上的进程（或线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;left&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;right&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1 get &quot;</span> + s1 + <span class="string">&quot; wait &quot;</span> + s2);</span><br><span class="line">            <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;1 get &quot;</span> + s2 + <span class="string">&quot; eat&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;2 get &quot;</span> + s2 + <span class="string">&quot; wait &quot;</span> + s1);</span><br><span class="line">            <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;2 get &quot;</span> + s1 + <span class="string">&quot; eat&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<h4 id="2-锁用过没"><a href="#2-锁用过没" class="headerlink" title="2. 锁用过没"></a>2. 锁用过没</h4><blockquote>
<p>滴滴19年秋招本科</p>
</blockquote>
<p>我们常说的锁有两种，一种是synchronized，另一种是ReentrantLock</p>
<p><strong>锁的什么方法你用过</strong></p>
<ul>
<li>lock：通过acquire加锁</li>
</ul>
<ul>
<li>getHoldCount：获得当前线程重入锁的次数，如果没有则为0</li>
</ul>
<p><strong>lock和tryLock区别</strong></p>
<ul>
<li>lock是调用了<code>acquire()</code>可以加公平锁，也可以加非公平锁，但是tryLock的无参方法只能加非公平锁</li>
<li>对tryLock(arg, nanosTimeOut)来说，如果在给定的等待时间内没有被其他线程持有，并且当前线程没有被中断，则获取锁。 它通过<code>acquire()</code>实现，既可以是公平锁，也可以是非公平锁</li>
</ul>
<p><strong>ReenTrantLock的公平锁和非公平锁的怎么实现的（源码级别），不限于概念</strong></p>
<p>公平锁比非公平锁在获取时加了一个判断条件，就是只有当该node节点前面没有节点或者该队列是空队列的时候才加锁</p>
<h4 id="3-Java里怎么实现缓存一致性的"><a href="#3-Java里怎么实现缓存一致性的" class="headerlink" title="3. Java里怎么实现缓存一致性的"></a>3. Java里怎么实现缓存一致性的</h4><blockquote>
<p>滴滴19年秋招本科</p>
</blockquote>
<p>volatile、synchronized、lock、信号量、wait/notify</p>
<p>面试官补充：信号量也是加锁实现的</p>
<h4 id="4-jvm的锁优化有什么"><a href="#4-jvm的锁优化有什么" class="headerlink" title="4. jvm的锁优化有什么"></a>4. jvm的锁优化有什么</h4><blockquote>
<p>滴滴19年秋招本科</p>
</blockquote>
<p>对于synchronized来说，在JDK1.6之后，优化了相当一部分内容，其中有自旋锁，锁消除，偏向锁，锁粗化，</p>
<ul>
<li>偏向锁：<strong>经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</strong>当一个线程访问同步块并获取锁时，会在<strong>对象头和栈帧中的锁记录里存储偏向的线程ID</strong>，以后该线程在<strong>进入和退出同步块时不需要进行 CAS 操作来加锁和解锁</strong>，只需简单的测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。测试成功则获得该锁，失败会去检查MarkWord中<strong>偏向锁的标志</strong>。如果标志为0，则用CAS竞争锁。如果设置为1，即当前是偏向锁， 则尝试使用 CAS 将对象头的偏向锁指向当前线程。</li>
<li>轻量级锁：偏向锁膨胀为轻量级锁之后，线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁，当自旋达到一定次数之后未获得锁，便会膨胀成重量级锁。</li>
<li>适应性自旋锁：线程加锁的时间一般都很短，所以下一个需要获得锁的线程等一下在阻塞，这个等一下的过程就叫自旋。这种优化方法叫自旋锁。而所谓的自适应自旋锁就是说线程等待的时间不是固定的。自旋锁在1.4就有，只不过默认的是关闭的，jdk1.6是默认开启的</li>
</ul>
<p><strong>那还有其他编译器的锁优化吗，比如锁粗化</strong></p>
<p>同时还有锁粗化和轻量级锁</p>
<ul>
<li>锁粗化：JIT优化，防止对同一个对象连续加锁和解锁。增大了锁的粒度</li>
<li>锁消除：JIT通过逃逸分析技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。 如果是，则消除synchronized，即不用加锁</li>
</ul>
<h4 id="5-volatile关键字的两层语义"><a href="#5-volatile关键字的两层语义" class="headerlink" title="5. volatile关键字的两层语义"></a>5. volatile关键字的两层语义</h4><blockquote>
<p>阿里19年秋招本科</p>
</blockquote>
<p>一层是可以防止重排序，保证了有序性；另外一层是能够立刻把工作内存的值刷新到主内存，并把其他线程的工作内存的值置为无效，保证了可见性</p>
<p><strong>它的底层原理是啥呢</strong></p>
<p>对于可见性来说volatile通过加lock锁保证了</p>
<ul>
<li>read、load、use动作必须<strong>连续出现</strong>。(把变量从主内存读到工作内存，把工作内存的值放入变量副本中，把变量副本的值传给执行引擎)</li>
<li>assign、store、write动作必须<strong>连续出现</strong>。(把执行引擎的值赋值给工作内存的变量副本，把工作内存的变量传到主内存中，把主内存的值放入变量中)</li>
</ul>
<p>对于有序性来说，编译器在生成字节码时，会在指令序列中插入<strong>内存屏障</strong>来禁止特定类型的处理器重排序。然而，对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的前面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<h4 id="6-volatile的内部原理"><a href="#6-volatile的内部原理" class="headerlink" title="6. volatile的内部原理"></a>6. volatile的内部原理</h4><blockquote>
<p>三七互娱19年春招，华为19年社招，小米19年秋招本科，京东19年秋招本科</p>
</blockquote>
<p>JMM内存模型，冲刷线程中的缓存</p>
<p>参考第五题</p>
<h4 id="7-volatile的具体使用场景"><a href="#7-volatile的具体使用场景" class="headerlink" title="7. volatile的具体使用场景"></a>7. volatile的具体使用场景</h4><blockquote>
<p>三七互娱19年春招</p>
</blockquote>
<p>总的来说有两种：</p>
<ol>
<li>对变量的写操作不依赖于当前值（i++）</li>
<li>该变量没有包含在具有其他变量的不变式中（setUp，setLow）</li>
</ol>
<p>具体场景如下：</p>
<ol>
<li>Boolean类型的状态标志（可见性）</li>
<li>一次性安全发布（单例模式，有序性）</li>
<li>独立观察对象的发布</li>
<li>JavaBean</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mbmispig/article/details/79255959">具体使用场景</a></p>
<h4 id="8-Java中的锁如何实现的"><a href="#8-Java中的锁如何实现的" class="headerlink" title="8. Java中的锁如何实现的"></a>8. Java中的锁如何实现的</h4><blockquote>
<p>阿里19年秋招</p>
</blockquote>
<p>参看第16题</p>
<h4 id="9-有什么能保证可见性"><a href="#9-有什么能保证可见性" class="headerlink" title="9. 有什么能保证可见性"></a>9. 有什么能保证可见性</h4><blockquote>
<p>pdd19年实习，京东19年秋招本科</p>
</blockquote>
<p>有三种办法，第一种是加锁，即synchronized和ReentrantLock，第二种是volatile，最后一种是final</p>
<ol>
<li>被synchronized修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁<strong>之前</strong>，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值</li>
<li>而ReentrantLock则是通过volatile来实现可见性的，因为lock和unlock是通过volatile修饰的state来实现的，因为state具有可见性，根据happens-before的传递性，在lock到unlock之间的代码也是可见的</li>
<li>对于volatile来说，被volatile修饰的属性能够立刻把工作内存的值刷新到主内存，并把其他线程的工作内存的值置为无效，保证了可见性</li>
<li>对于final来说，被final修饰的字段在构造器中一旦初始化完成，并且没有this逃逸，那在其他线程中就能看见final字段的值。因为final是不可变的，所以满足可见性</li>
</ol>
<h4 id="10-sync的内部实现，以及优化"><a href="#10-sync的内部实现，以及优化" class="headerlink" title="10. sync的内部实现，以及优化"></a>10. sync的内部实现，以及优化</h4><blockquote>
<p>头条19年实习，小米19年秋招本科，字节跳动19年秋招本科</p>
</blockquote>
<p>对于修饰方法来说，会在字节码的flags中表明为ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，如果有设置，则需要先获得监视器锁，然后开始执行方法，方法执行之后再释放监视器锁。这时如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放</p>
<p>当修饰代码块时，会在字节码中通过 <code>monitorenter</code> 和 <code>monitorexit</code> 执行来进行加锁。当线程执行到 <code>monitorenter</code> 的时候要先获得所锁，才能执行后面的方法。当线程执行到 <code>monitorexit</code> 的时候则要释放锁。每个对象自身维护这一个被加锁次数的计数器，当计数器数字为 0 时表示可以被任意线程获得锁。当计数器不为 0 时，只有获得锁的线程才能再次获得锁。即可重入锁。</p>
<p><strong>jvm接收到monitorenter的时候，会执行什么操作</strong></p>
<p>之后会调用<code>ObjectMonitor</code>的<code>enter</code>方法，解锁的时候会调用<code>exit</code>方法。<code>ObjectMonitor</code>是Monitor的实现，有三个主要数据结构</p>
<blockquote>
<p>_owner：指向持有ObjectMonitor对象的线程</p>
<p>_WaitSet：存放处于wait状态的线程队列</p>
<p>_EntryList：存放处于等待锁block状态的线程队列</p>
<p> _recursions：锁的重入次数 </p>
</blockquote>
<h4 id="11-synchronized优化过程-jdk1-6后-jvm层面"><a href="#11-synchronized优化过程-jdk1-6后-jvm层面" class="headerlink" title="11. synchronized优化过程 jdk1.6后 jvm层面"></a>11. synchronized优化过程 jdk1.6后 jvm层面</h4><blockquote>
<p>阿里19年秋招</p>
</blockquote>
<p>参见第四题</p>
<h4 id="12-synchronized标注不同的方法有什么区别"><a href="#12-synchronized标注不同的方法有什么区别" class="headerlink" title="12. synchronized标注不同的方法有什么区别"></a>12. synchronized标注不同的方法有什么区别</h4><blockquote>
<p>头条19年实习</p>
</blockquote>
<p>静态方法使用的是类锁，普通方法使用的是对象锁</p>
<h4 id="13-synchronized不同使用-区别"><a href="#13-synchronized不同使用-区别" class="headerlink" title="13. synchronized不同使用 区别"></a>13. synchronized不同使用 区别</h4><blockquote>
<p>阿里19年秋招</p>
</blockquote>
<p>synchronized可以同步代码块和方法。同步代码块时使用的是对象锁或类锁。同步静态方法时使用的是类锁，普通方法使用的是对象锁</p>
<h4 id="14-Lock如何给线程分配锁的"><a href="#14-Lock如何给线程分配锁的" class="headerlink" title="14. Lock如何给线程分配锁的"></a>14. Lock如何给线程分配锁的</h4><blockquote>
<p>滴滴19年秋招本科</p>
</blockquote>
<p>对于ReentrantLock来说，当调用lock方法时，会先判断state是否为0，如果为0，则通过CAS设置为1，并使得当前线程独占该锁，否则则通过acquire(1)方法去加锁。对于非公平锁来说，会调用<code>nonfairTryAcquire()</code>，对于非公平锁来说，会调用<code>tryAcquire()</code>。如果获得不到锁，则会将线程放入AQS的队列的队尾，并一直自旋尝试获得锁*(当然，如果前一个节点是SIGNAL，则阻塞当前线程，然后返回线程的中断状态并复位中断状态 ，这是为了防止一直自旋进而耗费CPU资源)*。如果整个过程异常，则取消该节点 </p>
<h4 id="15-synchronized和ReentrantLock的区别"><a href="#15-synchronized和ReentrantLock的区别" class="headerlink" title="15. synchronized和ReentrantLock的区别"></a>15. synchronized和ReentrantLock的区别</h4><blockquote>
<p>三七互娱19年春招</p>
<p>先说到了自旋锁，锁消除和锁粗化。最后扯到了Unsafe类就谈不下去了</p>
</blockquote>
<ul>
<li>都是可重入锁</li>
<li>synchronized是Java内置特性，而ReentrantLock是通过Java代码实现的</li>
<li>synchronized是可以自动获取/释放锁的，但是ReentrantLock需要手动获取/释放锁</li>
<li>ReentrantLock还具有响应中断、超时等待、中断等待等特性</li>
<li>ReentrantLock可以实现公平锁，而synchronized只是非公平锁</li>
<li> synchronized关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待/通知机制，ReentrantLock类需要借助于<code>Condition</code>接口与<code>newCondition() </code>方法。实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器）。线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify() / notifyAll()方法进行通知时，被通知的线程是由 JVM  选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知“。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程</li>
<li> synchronized除了在流程走完释放锁，还在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock 时需要在finally块中释放锁</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到</li>
</ul>
<h4 id="16-synchronized和ReentrantLock的原理"><a href="#16-synchronized和ReentrantLock的原理" class="headerlink" title="16. synchronized和ReentrantLock的原理"></a>16. synchronized和ReentrantLock的原理</h4><blockquote>
<p>三七互娱19年春招</p>
<p>问到AQS这一层，已经回答不出来了</p>
</blockquote>
<p>synchronized的原理参见第10题</p>
<p>对于ReentrantLock来说，它是一种可重入锁，有两种获取锁的模式：公平锁和非公平锁。所以对应有两个内部类，都继承自Sync。而Sync继承自AQS。因此，所谓的ReentrantLock原理不过也是分析一下Sync自己实现的<code>tryAcquire()</code>和<code>tryRelease()</code>方法罢了</p>
<ul>
<li>Sync主要重新实现了<code>tryRelease()</code>和<code>tryAcquire()</code>*(通过nonfairTryAcquire())*。对于第一个方法来说，会先判断当前线程和持有锁线程是否一样，如果一样并且当前释放是重入锁的最后一个，则把锁的独占线程置为空。之后再通过<code> unparkSuccessor()</code>去唤醒队列中的下一个线程。对于第二个方法来说，它的<code>nonfairTryAcquire()</code>主要是针对非公平锁，如果当前state为0，即锁中没有线程，则通过CAS去获得该锁，如果state&gt;0，则判断该线程是否和获得锁的线程一样，即是否是重入的</li>
<li>对于公平锁的<code>tryAcquire()</code>来说，它比非公平锁多了一个<code>!hasQueuedPredecessors()</code>的判断，即检查如果<strong>当前线程位于队列的最前面或队列为空</strong>，才会让它获得锁</li>
</ul>
<h4 id="17-synchronized锁对象和锁类的区别"><a href="#17-synchronized锁对象和锁类的区别" class="headerlink" title="17. synchronized锁对象和锁类的区别"></a>17. synchronized锁对象和锁类的区别</h4><blockquote>
<p>三七互娱19年春招</p>
</blockquote>
<ul>
<li><p>因为每个对象的MarkWord都有一个Monitor标志位，锁对象即通过该监视器锁进行加锁</p>
</li>
<li><p>锁类时其实也是锁的该类的class对象</p>
</li>
<li><p>主要区别是同一个类的不同对象使用类锁会是同步的</p>
</li>
</ul>
<h2 id="Java并发包"><a href="#Java并发包" class="headerlink" title="Java并发包"></a>Java并发包</h2><p>JUC中一共包含五种，分别是工具类*( CountDownLatch、CyclicBarrier、Semaphore )*，atomic，lock，并发容器和线程池。其中lock包括了AQS和ReentrantLock。同时 Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask也是基于AQS的</p>
<h4 id="1-atomic类的原理？-聊一聊使用的场景"><a href="#1-atomic类的原理？-聊一聊使用的场景" class="headerlink" title="1. atomic类的原理？ 聊一聊使用的场景"></a>1. atomic类的原理？ 聊一聊使用的场景</h4><blockquote>
<p>三七互娱19年春招</p>
</blockquote>
<p>atomic中一共有四大类，12个类，四种原子更新方式，分别是</p>
<ul>
<li>原子更新基本类型：<code>AtomicInteger</code>,<code>AtomicLong</code>,<code>AtomicBoolean</code></li>
<li>原子更新数组：<code>AtomicIntegerArray</code>,<code>AtomicLongArray</code>.<code>AtomicReferenceArray</code></li>
<li>原子更新引用：<code>AtomicReference</code>,<code>AtomicReferenceFieldUpdater</code>,<code>AtomicMarkableReference</code><em>(该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题 )</em></li>
<li>原子更新字段：<code>AtomicIntegerFieldUpdater</code>,<code>AtomicLongFieldUpdater</code>,<code>AtomicStampedReference</code><em>( 原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更数据和数据的版本号，可以解决使用CAS进行原子更新时，可能出现的ABA问题 )</em></li>
<li>Atomic包里的类基本都是使用Unsafe实现的包装类</li>
</ul>
<p>因为要保证原子性的，所以在++时加锁可能会更耗费资源，此时通过atomic包来实现绝对是一种明智的选择。即 当对<strong>一个</strong>共享变量的原子操作，使用atomic会方便的多</p>
<h4 id="2-juc看过哪些，说AQS的机制"><a href="#2-juc看过哪些，说AQS的机制" class="headerlink" title="2. juc看过哪些，说AQS的机制"></a>2. juc看过哪些，说AQS的机制</h4><blockquote>
<p>滴滴19年秋招本科，pdd19年实习</p>
</blockquote>
<p>JUC中有线程池(Worker基于AQS)，工具类(基于AQS的semaphore,countDownLock等)，并发容器，atomic和locks（AQS，ReentrantLock）</p>
<p><strong>概念</strong></p>
<p>对于AQS来说，他是一个用来构建锁和同步器的框架，基于CAS，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器</p>
<p><strong>使用</strong></p>
<p>从使用上来说，AQS的功能可以分为两种：独占（如ReentrantLock）和共享（如Semaphore/CountDownLatch CyclicBarrier/ReadWriteLock)。ReentrantReadWriteLock可以看成是组合式，它对读共享，写独占</p>
<p>AQS的设计是基于模板方法模式的，如果需要自定义同步器一般的方式，则需要：</p>
<ol>
<li><p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</p>
</li>
<li><p>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>

<p> 默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code> 。为什么不是abstract的呢？如果是abstract则说明每个使用者都要实现这些方法，要求比较苛刻。</p>
</li>
</ol>
<p><strong>原理</strong></p>
<ul>
<li><p>AQS维护一个共享资源<code>state</code>，它的语义有响应的子类来实现，譬如在<code>ReentrantLock</code>中，<code>state</code>初始化为0，表示未锁定状态。A线程<code>lock()</code>时，会调用<code>tryAcquire()</code>独占该锁并将state+1。此后，其他线程再<code>tryAcquire()</code>时就会失败，直到A线程<code>unlock()</code>到<code>state</code>=0（即释放锁）为止，其它线程才有机会获取该锁。在<code>CountDownLatch</code>中，任务分为N个子线程去执行，<code>state也</code>初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后<code>countDown()</code>一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会<code>unpark()</code>主调用线程，然后主调用线程就会从await()函数返回，继续后余动作 </p>
</li>
<li><p>AQS通过内置的FIFO双端双向链表来完成获取资源线程的排队工作，双端双向链表。该队列由一个一个的<code>Node</code>结点组成，每个<code>Node</code>结点维护一个<code>prev</code>引用和<code>next</code>引用，分别指向自己的前驱和后继结点。AQS维护两个指针，分别指向队列头部<code>head</code>和尾部<code>tail</code>。该队列中的<code>Node</code>有五种状态，分别是<code>CANCELLED</code>,<code>SIGNAL</code>, <code>CONDITION</code>,<code>PROPAGATE</code>和初始状态</p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示<strong>当前结点</strong>已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化</li>
<li><strong>SIGNAL</strong>(-1)：表示<strong>后继结点</strong>在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL</li>
<li><strong>CONDITION</strong>(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点</li>
<li><strong>0</strong>：新结点入队时的默认状态</li>
</ul>
</li>
<li><p>当加锁时，子类通过调用AQS的<code>acquire()</code>进而调用子类自己实现的<code>tryAcquire()</code>方法（该方法是尝试获得锁，即改变state的状态），在调用<code>tryAcquire()</code>方法的过程中：先尝试获得锁，如果成功则返回，如果获得不成功则把该线程加入到Node队列中*(节点为空时，自旋创建节点并设置尾点)<em>，然后自旋尝试获得锁</em>(只有老二结点，才有机会去tryAcquire，如果不是且当其前驱节点是SINGAL，则阻塞)*，之后返回中断状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) </span><br><span class="line">    &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))            </span><br><span class="line">    selfInterrupt();</span><br></pre></td></tr></table></figure>
</li>
<li><p>当释放锁时，和加锁流程一样。当释放成功后则去唤醒后面的节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>组件</strong></p>
<p>除了ReentrantLock外，还有三种常用的AQS组件，分别是<code>Semaphore</code>,<code>CountDownLatch</code>和<code>CyclicBarrier</code></p>
<ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。(PS:学过OS的应该都知道把)</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比  CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier  的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉  CyclicBarrier 我已经到达了屏障，<strong>然后当前线程被阻塞</strong></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://ideabuffer.cn/2017/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%B8%80%EF%BC%89/">深入理解AQS（一）</a></p>
<p><a target="_blank" rel="noopener" href="https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/JavaConcurrencyAdvancedCommonInterviewQuestions?id=_6-aqs">Guide</a></p>
<h4 id="3-了解juc？说说juc，举个例子"><a href="#3-了解juc？说说juc，举个例子" class="headerlink" title="3. 了解juc？说说juc，举个例子"></a>3. 了解juc？说说juc，举个例子</h4><blockquote>
<p>京东19年秋招本科，阿里19年秋招</p>
</blockquote>
<p>JUC中有线程池(Worker基于AQS)，工具类(基于AQS的semaphore,countDownLock等)，并发容器，atomic和locks（AQS，ReentrantLock）</p>
<p>对于ConcurrentHashMap来说，因为HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 <code>Collections.synchronizedMap()</code> 方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p>
<p>所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。在 ConcurrentHashMap  中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问</p>
<h4 id="4-atomic下的原子类有用到吗？"><a href="#4-atomic下的原子类有用到吗？" class="headerlink" title="4. atomic下的原子类有用到吗？"></a>4. atomic下的原子类有用到吗？</h4><blockquote>
<p>阿里19年秋招，bigo19年秋招本科</p>
</blockquote>
<p>用到了AtomicInteger，底层是用的CAS实现的</p>
<p>AtomicInteger 类主要利用 CAS+ volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升</p>
<p>在JDK8中，对于<code>getAndIncrement()</code>来说，会直接调用<code>unsafe.getAndAddInt()</code>方法，之后会通过两个native方法<code>getIntVolatile(o, offset)</code>和<code>weakCompareAndSetInt()</code>，第一个方法的作用是从给定偏移量的内存地址获取给定对象o中的字段或数组元素，第二个方法的作用是通过CAS去更新值，CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值</p>
<h4 id="5-CAS"><a href="#5-CAS" class="headerlink" title="5. CAS"></a>5. CAS</h4><p><strong>原理，产生问题，如何解决，使用场景</strong></p>
<blockquote>
<p>三七互娱19年春招，oppo19年秋招本科，bigo19年秋招本科</p>
</blockquote>
<ol>
<li>CAS怎么实现的<ul>
<li>CAS是在JDK5引进的，通过UnSafe类实现</li>
<li>JDK8以前和JDK8（包括8）以后的实现方式略有不同，但总体一样</li>
</ul>
</li>
<li>CAS本质性实现原理是什么？<ul>
<li>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值 </li>
<li>但是可能会出现ABA问题，可以通过版本号机制解决</li>
</ul>
</li>
</ol>
<h4 id="6-如何避免CAS一直自旋消耗资源"><a href="#6-如何避免CAS一直自旋消耗资源" class="headerlink" title="6. 如何避免CAS一直自旋消耗资源"></a>6. 如何避免CAS一直自旋消耗资源</h4><blockquote>
<p>字节跳动19年秋招本科</p>
</blockquote>
<p>可以为自旋时间加上限制，如果自旋超过一定时间之后，就将该线程放置为阻塞状态。像AQS中的<code>acquireQueue</code>方法就用了这种手段，如果该节点的前置节点是SIGNAL，则阻塞该线程</p>
<h4 id="7-CAS比分段锁好在哪里，缺点又是什么"><a href="#7-CAS比分段锁好在哪里，缺点又是什么" class="headerlink" title="7. CAS比分段锁好在哪里，缺点又是什么"></a>7. CAS比分段锁好在哪里，缺点又是什么</h4><blockquote>
<p>字节跳动19年秋招本科</p>
</blockquote>
<p>将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，这就是<strong>分段锁</strong></p>
<p>不用加锁，效率更高</p>
<p>但是会产生ABA问题，一直自旋会消耗CPU资源</p>
<h4 id="8-CAS算法在哪里有应用？"><a href="#8-CAS算法在哪里有应用？" class="headerlink" title="8. CAS算法在哪里有应用？"></a>8. CAS算法在哪里有应用？</h4><blockquote>
<p>阿里19年秋招</p>
</blockquote>
<p>JDK整个JUC包都是基于CAS算法的</p>
<h4 id="9-讲一下ConcurrentHashMap"><a href="#9-讲一下ConcurrentHashMap" class="headerlink" title="9. 讲一下ConcurrentHashMap"></a>9. 讲一下ConcurrentHashMap</h4><blockquote>
<p>阿里19年秋招</p>
</blockquote>
<p>参看集合面经</p>
<h4 id="10-Hashmap和Concurrenthashmap"><a href="#10-Hashmap和Concurrenthashmap" class="headerlink" title="10. Hashmap和Concurrenthashmap"></a>10. Hashmap和Concurrenthashmap</h4><blockquote>
<p>滴滴19年秋招本科，科大讯飞19年秋招本科，pdd19年实习</p>
</blockquote>
<p>这个和集合也密切相关，我集合面经中有说</p>
<p><strong>各版本的区别</strong></p>
<p>JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现</p>
<p>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树 </p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>这个模块我在JavaEE Plus模块中也有细说</p>
<h4 id="1-分布式锁和锁区别，什么时候用，怎么考虑的"><a href="#1-分布式锁和锁区别，什么时候用，怎么考虑的" class="headerlink" title="1. 分布式锁和锁区别，什么时候用，怎么考虑的"></a>1. 分布式锁和锁区别，什么时候用，怎么考虑的</h4><blockquote>
<p>京东19年秋招</p>
</blockquote>
<p>普通锁针对多线程的场景，一般可以synchronized和lock。而分布式针对的是分布式的环境，系统部署在多个机器中，也会出现并发问题，并且场景是多个进程之间的并发问题。使用内存标记无法解决这个问题，因为内存是线程共享的</p>
<p>分布式锁是防止多进程出现并发问题，所以不可以借助内存来实现锁的功能。但是可以借助redis、memcached（Memcached 是一个高性能的分布式内存对象缓存系统）、zookeeper实现。</p>
<h4 id="2-分布式锁的实现手段有哪些"><a href="#2-分布式锁的实现手段有哪些" class="headerlink" title="2. 分布式锁的实现手段有哪些"></a>2. 分布式锁的实现手段有哪些</h4><blockquote>
<p>京东19年秋招</p>
</blockquote>
<ul>
<li>zookeeper。每个客户端对某个功能加锁时，在zookeeper上的与该功能对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。优点：锁安全性高，zk可持久化。缺点：性能开销比较高。因为其需要动态产生、销毁瞬时节点来实现锁功能</li>
<li>memcached带有add函数，利用add函数的特性即可实现分布式锁。add和set的区别在于：如果多线程并发set，则每个set都会成功，但最后存储的值以最后的set的线程为准。而add的话则相反，add会添加第一个到达的值，并返回true，后续的添加则都会返回false。利用该点即可很轻松地实现分布式锁。优点：并发高效。缺点：memcached采用列入LRU置换策略，所以如果内存不够，可能导致缓存中的锁信息丢失。memcached无法持久化，一旦重启，将导致信息丢失</li>
<li>redis可以使用jedis.set实现，并且设置过期时间，否则如果加完锁出现故障就会导致死锁*(redis获取锁的那个客户端bug了或者挂了，那么只能等待超时时间之后才能释放锁)*。redis分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能</li>
</ul>
<h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><h4 id="1-当数据正在更新，如何解决不同线程更新一个变量的问题"><a href="#1-当数据正在更新，如何解决不同线程更新一个变量的问题" class="headerlink" title="1. 当数据正在更新，如何解决不同线程更新一个变量的问题"></a>1. 当数据正在更新，如何解决不同线程更新一个变量的问题</h4><blockquote>
<p>三七互娱19年春招</p>
</blockquote>
<p>使用锁或者atomic</p>
<h4 id="2-怎么获得一个线程安全的list"><a href="#2-怎么获得一个线程安全的list" class="headerlink" title="2. 怎么获得一个线程安全的list"></a>2. 怎么获得一个线程安全的list</h4><blockquote>
<p>瓜子二手车秋招本科</p>
</blockquote>
<p>通过<code>Collections.synchronizedList(new ArrayList());</code></p>
<h2 id="实操题"><a href="#实操题" class="headerlink" title="实操题"></a>实操题</h2><h4 id="3-生产者消费者模型"><a href="#3-生产者消费者模型" class="headerlink" title="3. 生产者消费者模型"></a>3. 生产者消费者模型</h4><blockquote>
<p>阿里19年秋招，京东19年秋招本科</p>
</blockquote>
<p>有多种方式：</p>
<ul>
<li>synchronized+wait/notifyAll</li>
<li>ReentrantLock+Condition</li>
<li>Semaphore</li>
<li>PipedInputStream+PipedOutputStream</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProAndCon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BUFFER = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore empty = <span class="keyword">new</span> Semaphore(BUFFER);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore full = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> in = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> out = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                empty.acquire();</span><br><span class="line">                mutex.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;生产&quot;</span> + in);</span><br><span class="line">                in = (in + <span class="number">1</span>) % BUFFER;</span><br><span class="line">                mutex.release();</span><br><span class="line">                full.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                full.acquire();</span><br><span class="line">                mutex.acquire();</span><br><span class="line">                System.out.println(<span class="string">&quot;消费&quot;</span> + out);</span><br><span class="line">                out = (out + <span class="number">1</span>) % BUFFER;</span><br><span class="line">                mutex.release();</span><br><span class="line">                empty.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer()).start();</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有什么注意事项</strong></p>
<h4 id="4-通过N个线程顺序循环打印从0至100"><a href="#4-通过N个线程顺序循环打印从0至100" class="headerlink" title="4. 通过N个线程顺序循环打印从0至100"></a>4. 通过N个线程顺序循环打印从0至100</h4><blockquote>
<p>阿里19年秋招本科</p>
</blockquote>
<p>如给定N=3则输出：<br>thread0: 0<br>thread1: 1<br>thread2: 2<br>thread0: 3<br>thread1: 4<br>…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqPrint</span> </span>&#123;</span><br><span class="line">    <span class="comment">//工作线程数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_COUNT = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//是计数器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> countIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="keyword">final</span> List&lt;Condition&gt; conditions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; WORKER_COUNT; i++)&#123;</span><br><span class="line">            Condition condition = reentrantLock.newCondition();</span><br><span class="line">            conditions.add(condition);</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(i, reentrantLock, conditions);</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conditions.get(<span class="number">0</span>).signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        ReentrantLock lock;</span><br><span class="line">        List&lt;Condition&gt; conditions;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> index, ReentrantLock lock, List&lt;Condition&gt; conditions)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(<span class="string">&quot;Worker:&quot;</span>+index);</span><br><span class="line">            <span class="keyword">this</span>.index = index;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">            <span class="keyword">this</span>.conditions = conditions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNext</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex = (index + <span class="number">1</span>) % conditions.size();</span><br><span class="line">            conditions.get(nextIndex).signal();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditions.get(index).await();</span><br><span class="line">                    <span class="keyword">if</span> (countIndex &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                        signalNext();</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println((<span class="keyword">this</span>.getName() + <span class="string">&quot; &quot;</span> + countIndex));</span><br><span class="line">                    countIndex ++;</span><br><span class="line">                    signalNext();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-手写一个计数器，开10个线程-保证最后计数输出为10"><a href="#5-手写一个计数器，开10个线程-保证最后计数输出为10" class="headerlink" title="5. 手写一个计数器，开10个线程,保证最后计数输出为10"></a>5. 手写一个计数器，开10个线程,保证最后计数输出为10</h4><blockquote>
<p>阿里19年秋招本科</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Counter</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        count = <span class="keyword">new</span> AtomicInteger(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">int</span> memory = count.get();</span><br><span class="line">            <span class="keyword">if</span> (count.compareAndSet(memory, memory + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - time &gt; <span class="number">10L</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Counter counter = <span class="keyword">new</span> Counter(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            counter.add();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(counter.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





























<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/344311?type=2&order=4&pos=3&page=3">牛客总结</a></p>
<ol>
<li>线程状态，start,run,wait,notify,yield,sleep,join等方法的作用以及区别 </li>
<li>wait,notify阻塞唤醒确切过程？在哪阻塞，在哪唤醒？为什么要出现在同步代码块中，为什么要处于while循环中？  </li>
<li>线程中断，守护线程  </li>
<li>Java乐观锁机制，CAS思想？缺点？是否原子性？如何保证？  </li>
<li>synchronized使用方法？底层实现？  </li>
<li>ReenTrantLock使用方法？底层实现？和synchronized区别</li>
<li>公平锁和非公平锁区别？为什么公平锁效率低？  </li>
<li>锁优化。自旋锁、自适应自旋锁、锁消除、锁粗化、偏向锁、轻量级锁、重量级锁解释  </li>
<li>Java内存模型  </li>
<li>volatile作用？底层实现？禁止重排序的场景？单例模式中volatile的作用？ </li>
<li>AQS思想，以及基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore介绍  </li>
<li>线程池构造函数7大参数，线程处理任务过程，线程拒绝策略  </li>
<li>Execuors类实现的几种线程池类型，阿里为啥不让用？ </li>
<li>线程池大小如何设置？</li>
<li>手写简单的线程池，体现线程复用  </li>
<li>手写消费者生产者模式</li>
<li>手写阻塞队列</li>
<li>手写多线程交替打印ABC</li>
</ol>
<p>总结：</p>
<p>关键字：synchronized（实现，优化），volatile，final</p>
<p>概念：JMM，happens-before</p>
<p>JUC：线程池，容器(COW)，工具类（借助了AQS），lock（AQS,ReentrantLock,ReadAndWriteLock），atomic</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-14</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Interview/" title="Interview">Interview </a><a class="tag" href="/tags/Java/" title="Java">Java </a><a class="tag" href="/tags/Concurrent/" title="Concurrent">Concurrent </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://wxxlamp.cn/2020/12/14/java-concurrent-interview/,王星星的魔灯,Java并发常见面试题,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/12/14/just-talk/" title="最近小感">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/12/14/data-too-long/" title="字段超过数据库范围的重构方案">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'',
  app_key:'',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>