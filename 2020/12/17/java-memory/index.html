<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="王星星"><title>类在内存中的存储方式 · 王星星的魔灯</title><meta name="description" content="Java有许多特点，如线程并发，类加载，垃圾回收，语法糖，丰富的官方类库，易懂的面向对象设计，平台兼容等等。对于内存来说，从宏观上，主要分为静态和动态两部分，静态的是内存的空间结构，动态的是内存的分配和回收。本篇文章，就来总结一下Java中的内存结构。
1. 语言间的内存差异相对于C来说，在对内存的"><meta name="keywords" content="王星星的魔灯,博客,王星星"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><!-- 增加网站logo--><link rel="shortcut icon" href="/assets/img/favicon.ico" type="image/x-icon"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">王星星的魔灯</a></h3><div class="description"><p>勇士斗恶龙 <br> Love & Seriousness & Regularity & Persistence</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/wxxlamp"><i class="fa fa-github"></i></a></li><li><a href="mailto:stalern2000@163.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2305450070&amp;site=qq&amp;menu=yes"><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/coder_what"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"><span>© 2018 - 2021</span><i class="fa fa-star"></i><span> 王星星</span><!--span.leancloud_visitors--></div><div class="by_farbox"><span>Powered by</span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a><span> &</span><a href="https://github.com/wxxlamp/anatole-core-wxx" target="_blank">Anatole-Wxx</a></div><div class="beian"><a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备20004458号-1</a><span style="height:10px;margin-left: 10px;">|</span><img src="/images/gongan.png" style="height:10px;margin-left: 10px;position: relative;top: 1px;"><span style="margin-left: 2px;">豫公网安备 44030400004458号</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/categories">分类</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>类在内存中的存储方式</a></h3></div><div class="post-content"><p>Java有许多特点，如线程并发，类加载，垃圾回收，语法糖，丰富的官方类库，易懂的面向对象设计，平台兼容等等。对于内存来说，从宏观上，主要分为静态和动态两部分，静态的是内存的空间结构，动态的是内存的分配和回收。本篇文章，就来总结一下Java中的内存结构。</p>
<h3 id="1-语言间的内存差异"><a href="#1-语言间的内存差异" class="headerlink" title="1. 语言间的内存差异"></a>1. 语言间的内存差异</h3><p>相对于C来说，在对内存的处理方式上，Java做了两点不同的决策。</p>
<h4 id="1-2-内存的空间结构"><a href="#1-2-内存的空间结构" class="headerlink" title="1.2 内存的空间结构"></a>1.2 内存的空间结构</h4><p>对于C来说，程序员会以系统的视角去看内存——一块连续的字节数组。一个C程序最起码是一个进程，它会直接映射到操作系统对进程的空间分配中，如程序块和数据，用户栈，运行堆，共享库以及用户无法访问的内核虚拟内存。一个简单的<code>HelloWorld.c</code>程序，它的代码会存放到程序块区域，静态变量会存放到数据区，当调用函数时，会把函数地址和变量压入用户栈中，当使用malloc分配空间时，数据会存放在运行堆中。</p>
<p>对于Java来说，VM会对内存再进行一次抽象和封装。它把内存分为线程独有的程序计数器、虚拟机栈、本地方法栈和线程共享的堆以及方法区(其实方法区也是堆)。当程序new一个对象后，对象的实例会被存放到堆中，对象的信息和方法以及静态变量会被存放到方法区中。</p>
<p>总结来说，C语言中，程序员可以访问的内存单位是字节数组；而Java语言中，程序员可以访问的内存单位是抽象出来的对象。因为寄存器可以访问的内存单位也是字节数组，这说明使用C语言的程序员可以直接访问底层，进行更多操作，这也是C语言程序员鄙视Java程序员的一个重要原因之一。但是访问的更多不仅仅意味着权利，也以为着责任，因为没有对象级的抽象，导致了C程序尤其是大型程序会莫名奇妙的抛出缓冲区溢出，数组越界，乱码等等难以找到根源的问题。</p>
<h4 id="1-2-内存的分配回收"><a href="#1-2-内存的分配回收" class="headerlink" title="1.2 内存的分配回收"></a>1.2 内存的分配回收</h4><p>对于C来说，程序员需要主动去申请和释放内存。而对于Java来说，因为有了VM的存在，GC会自动回收不可达的对象。但是同时GC线程在回收垃圾的时候会造成STW（Stop the world），拖慢程序的性能。而且，因为对象交给了VM来负责清除，那么对象的清除时间其实是不可预测的。相对来说，C程序员可以完全操控内存的分配和回收时间，可以完全掌握内存的信息，这点是Java程序员做不到的。但是，如果C程序中忘记<code>free</code>内存空间，也将会造成不可估量的损失。</p>
<p>从内存处理的方式来看，C程序有着不容置疑的对内存完全掌控的能力，而对Java程序来说，因为VM做了一层抽象后，Java程序把内存的操作交给了VM来处理，变成了间接访问。同时，因为有了VM，Java程序可以随心所欲的编写代码而不用担心出现很大的BUG，这导致了Java语言极易上手，Java程序员良莠不齐，一直被行业诟病。</p>
<h3 id="2-Java中的内存结构"><a href="#2-Java中的内存结构" class="headerlink" title="2. Java中的内存结构"></a>2. Java中的内存结构</h3><p>Java的内存结构几乎是面试必问的一个问题，所以这里再拉出来回顾一下。</p>
<blockquote>
<p>以下内存结构针对JDK8</p>
</blockquote>
<h4 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><ul>
<li><strong>虚拟机栈</strong>：线程私有，每个方法非native方法对应一个栈帧，栈帧中包括局部变量表(以slot为基本单位，存储方法参数和内部变量)，操作数栈（存储计算参数和结果），动态链接等</li>
<li><strong>本地方法栈</strong>：线程私有，负责native方法</li>
<li><strong>程序计数器</strong>：线程私有，记录某个线程的字节码执行位置</li>
<li><strong>堆</strong>：线程共有，用来存放实例，是Jvm最大的一块区域，也是GC管理的主要区域。在JDK7及以前，分为新生代*( Eden 8、From Survivor 1、To Survivor 1 )*，老年代。新生代与老年代是1:2</li>
<li><strong>方法区</strong>：存储类的结构信息，除了运行时常量池，其他的都在MetaSpace中放着<ol>
<li>运行时常量池，运行时将常量池的数据放入这里，同时包括字符串常量池，这个实际是在堆中放着，可以动态变化（如<code>String#intern()</code>）</li>
<li>常量池，存放编译期生成的字面量（文本字符串、八种基本类型的值、被声明为final的常量）以及符号引用（类和方法的全限定名、字段的名称和描述符、方法的名称和描述符），大小在运行期前已知。以类为单位</li>
<li>方法字节码，存放的是各个方法的字节码（依赖操作数栈和局部变量表，由JVM解释执行）</li>
</ol>
</li>
</ul>
<p>理论知识可以参考 <a target="_blank" rel="noopener" href="https://mritd.com/2006/01/02/java-memory-overview-of-vm-memory-auto-management-and-memory-regions/">Bleem1</a>、<a target="_blank" rel="noopener" href="https://mritd.com/2006/01/02/java-memory-method-area-and-runtime-constant-pool/">Bleem2</a>、<a href="">Bleem3</a></p>
<h4 id="2-2-程序演示"><a href="#2-2-程序演示" class="headerlink" title="2.2 程序演示"></a>2.2 程序演示</h4><p>对于一个类来说，它主要分为两部分，分别是属性和方法。这两部分和我们计算机基础中的数据结构和算法是一一对应的。对于C程序来说，数据结构存放在堆中，算法存放在代码块中。下面，我们通过一个程序来说明Java程序的这两部分分别存放在哪里？</p>
<blockquote>
<p>分配情况不考虑TLAB，JIT，逃逸分析等，同时也不考虑Eden和Survivor这些区域</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryStructTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLO_WORLD = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        String helloWorld = HELLO_WORLD;</span><br><span class="line">        System.out.print(helloWorld);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当该程序被编译、类加载、初始化和运行时，这个程序在内存中是什么样子的呢？</p>
<ul>
<li><code>MemoryStructTest</code>这个类的信息在类加载之后会被存储到方法区中。其中，包括Field，Method，常量池，static变量，类名等</li>
<li>类加载的最后一步初始化会去初始化static变量<code>HELLO_WORLD</code>，此时会去对String类进行类加载，<code>String</code>类会被按照刚才的方式类加载进入方法区，然后<code>HELLO_WORLD</code>这个字符串的引用会被字符串常量池中，而它真正被存在了堆中。而<code>helloworld</code>这个本地变量则是存在了虚拟机栈中了。</li>
<li>在运行之后，之前常量池的部分内容会被拷贝到运行时常量池中，同时，该类的然后VM开始逐行解释执行方法区<code>main</code>方法的字节码</li>
<li>当调用到第五行的时候，会对<code>System.out</code>这个类类加载到方法区，之后调用方法区中的静态方法，打印<code>helloWorld</code>这个本地变量</li>
</ul>
<p>可以得到下图：</p>
<p><img src="/assets/post/java-memory-1.png"></p>
<p>有一点需要注意的是，对于String和基本类型，如果不主动new，它们会在常量池中，如果主动new，则会产生在堆中</p>
<h3 id="3-具体类型的存储格式"><a href="#3-具体类型的存储格式" class="headerlink" title="3. 具体类型的存储格式"></a>3. 具体类型的存储格式</h3><h4 id="3-1-父类的存储格式"><a href="#3-1-父类的存储格式" class="headerlink" title="3.1 父类的存储格式"></a>3.1 父类的存储格式</h4><p>这个是我大二时候画的一个内存图，现在看来，还是有些东西的，再次放上来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//产生新的虚(virtual)方法MethodVirtual(),new slot</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">MethodVirtual</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aV&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产生新的虚(virtual)方法MethodVirtual1,new slot</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">MethodVirtual1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aV1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖父类的MethodVirtual()方法，reuse slot</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">MethodVirtual</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bV&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖父类的MethodVirtual1()方法，reuse slot</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">MethodVirtual1</span><span class="params">()</span>	</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bV1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 覆盖MethodVirtual()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MethodVirtual</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dV&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖MethodVirtual()1方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">MethodVirtual1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dV1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A_Polymorphism</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a;</span><br><span class="line">        B b;</span><br><span class="line">        C c;</span><br><span class="line">        D d;</span><br><span class="line"></span><br><span class="line">        a = <span class="keyword">new</span> A();</span><br><span class="line">        b = <span class="keyword">new</span> B();</span><br><span class="line">        c = <span class="keyword">new</span> C();</span><br><span class="line">        d = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">        A ab = b;</span><br><span class="line">        A ac = c;</span><br><span class="line">        A ad = d;</span><br><span class="line"></span><br><span class="line">        B bc = c;</span><br><span class="line">        B bd = d;</span><br><span class="line"></span><br><span class="line">        C cd = d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------方法多态---------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------a.MethodVirtual()---------------------------&quot;</span>);</span><br><span class="line">        a.MethodVirtual();</span><br><span class="line">        ab.MethodVirtual();</span><br><span class="line">        ac.MethodVirtual();</span><br><span class="line">        ad.MethodVirtual();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------a.MethodVirtual1()---------------------------&quot;</span>);</span><br><span class="line">        a.MethodVirtual1();</span><br><span class="line">        ab.MethodVirtual1();</span><br><span class="line">        ac.MethodVirtual1();</span><br><span class="line">        ad.MethodVirtual1();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------b.MethodVirtual()---------------------------&quot;</span>);</span><br><span class="line">        b.MethodVirtual();</span><br><span class="line">        bc.MethodVirtual();</span><br><span class="line">        bd.MethodVirtual();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------b.MethodVirtual1()---------------------------&quot;</span>);</span><br><span class="line">        b.MethodVirtual1();</span><br><span class="line">        bc.MethodVirtual1();</span><br><span class="line">        bd.MethodVirtual1();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------c.MethodVirtual()---------------------------&quot;</span>);</span><br><span class="line">        c.MethodVirtual();</span><br><span class="line">        cd.MethodVirtual();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------c.MethodVirtual1()---------------------------&quot;</span>);</span><br><span class="line">        c.MethodVirtual1();</span><br><span class="line">        cd.MethodVirtual1();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------d.MethodVirtual()---------------------------&quot;</span>);</span><br><span class="line">        d.MethodVirtual();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------d.MethodVirtual1()---------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//d = null;</span></span><br><span class="line">        d.MethodVirtual1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190815120936937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGVyX3doYXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-2-接口的存储格式"><a href="#3-2-接口的存储格式" class="headerlink" title="3.2 接口的存储格式"></a>3.2 接口的存储格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">o</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;you can hit me&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span> <span class="keyword">extends</span> <span class="title">o</span> <span class="keyword">implements</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Stonee is so handsome&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;you can&#x27;t hit me because the interface don&#x27;t have me&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//inerface</span></span><br><span class="line">        I ic = <span class="keyword">new</span> c();</span><br><span class="line">        ic.func1(); <span class="comment">//ok</span></span><br><span class="line">        <span class="comment">//a.func2(); //no</span></span><br><span class="line">        ((c) ic).func2(); <span class="comment">//ok</span></span><br><span class="line">        ((c) ic).func(); <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//class parents</span></span><br><span class="line">        o oc = <span class="keyword">new</span> c();</span><br><span class="line">        oc.func();</span><br><span class="line">        ((c) oc).func1();</span><br><span class="line">        ((c) oc).func2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//class son</span></span><br><span class="line">        c cc = <span class="keyword">new</span> c();</span><br><span class="line">        cc.func1();</span><br><span class="line">        cc.func2();</span><br><span class="line">        cc.func();</span><br><span class="line"></span><br><span class="line">        o oo = <span class="keyword">new</span> o();</span><br><span class="line">        oo.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20190411183056417.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NvZGVyX3doYXQ=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>PS：上面的 “堆·类” 应该改为方法区</p>
</blockquote>
<h4 id="3-3-内部类的存储格式"><a href="#3-3-内部类的存储格式" class="headerlink" title="3.3 内部类的存储格式"></a>3.3 内部类的存储格式</h4><p>内部类通过语法糖会被解析为一个普通的类，然后和上边是一样的</p>
<h4 id="3-4-数组的存储格式"><a href="#3-4-数组的存储格式" class="headerlink" title="3.4 数组的存储格式"></a>3.4 数组的存储格式</h4><p>在Java中，数组也是一个对象，这样的抽象，极大程度上保证了对数组操作的安全性，不会产生C程序中的数组越界时内存覆盖的问题。</p>
<p>一个包含数组，接口，类以及继承的程序：</p>
<blockquote>
<p><strong>声明：本程序完全是为了演示接口，类等的内存逻辑模型的demo</strong><br><strong>另：此程序有点冗余，但确实可以说明继承关系，而且内存逻辑模型是用手画的，只画了一些重要部分，没有上面程序画的详细</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chapter06;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 关于接口和类的继承以及不规则数组的内存逻辑模型</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0 2019-4-8</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Stonee(http://www.stonee.club)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterfaceTestCourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    healthPigeon [][] a = <span class="keyword">new</span> healthPigeon[<span class="number">2</span>][];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="keyword">new</span> healthPigeon[<span class="number">1</span>];</span><br><span class="line">    a[<span class="number">1</span>] = <span class="keyword">new</span> healthPigeon[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (healthPigeon[] e:</span><br><span class="line">        a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (healthPigeon es:</span><br><span class="line">            e) &#123;</span><br><span class="line">            es = <span class="keyword">new</span> healthPigeon();    <span class="comment">//一定要先对数组赋值，不然会指向null，然后报错</span></span><br><span class="line">            System.out.println();</span><br><span class="line">            es.eat();</span><br><span class="line">            es.move();</span><br><span class="line">            es.breathe();</span><br><span class="line">            es.feather();</span><br><span class="line">            es.fly();</span><br><span class="line">            es.fxxk();</span><br><span class="line">            System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 定义接口</span></span><br><span class="line"> <span class="comment">// 定义父接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">canEat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;     <span class="comment">//默认修饰符为 public abstract</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fxxk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">canMove</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">fxxk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like move&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">canFly</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 子类已经重载，为什么说此方法未被调用？</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">canBreathe</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">breathe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;<span class="comment">// 定义子接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">bird</span> <span class="keyword">extends</span> <span class="title">canBreathe</span>,<span class="title">canFly</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feather</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 定义类</span></span><br><span class="line"> <span class="comment">// 定义父类</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">pigeon</span> <span class="keyword">implements</span> <span class="title">bird</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The pigeon have feather&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The pigeon can breathe&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The pigeon can fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 定义子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">healthPigeon</span> <span class="keyword">extends</span> <span class="title">pigeon</span> <span class="keyword">implements</span> <span class="title">canEat</span>,<span class="title">canMove</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The cute Pigeon can eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The cute pigeon can move&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fxxk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        canEat.fxxk();  <span class="comment">//此处必须声明调用接口的哪个默认方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src = "https://img-blog.csdnimg.cn/2019041118341719.jpg" style="transform:rotate(270deg)"/>

<h4 id="3-5-基本数据类型的存储格式"><a href="#3-5-基本数据类型的存储格式" class="headerlink" title="3.5 基本数据类型的存储格式"></a>3.5 基本数据类型的存储格式</h4><p>对于基本数据类型来说，如果是局部变量，则直接回按照字节规范分配到栈上。如果是类的全局变量，则随着实例的初始化分配到堆上。</p>
<p>如果类实例的某个属性是另外个实例，那么会有指针指向另外个实例。而如果属性是基本类型的话，则没有指向，直接分配这个这么大字节的空间</p>
<blockquote>
<p>附基本类型的字节：byte 1 字节，char 2 字节，short 2 字节，int 4 字节，float 4 字节， long 8 字节， double 8 字节，boolean 不确定</p>
</blockquote>
<h3 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h3><p>其实这些东西我在去年的这个时候都已经知道了，但是没有一个贯通的概念，今天一总结，才有种豁然开朗的感觉。</p>
<p>但是，了解的越多，才发现在不懂的越多，加油吧</p>
<blockquote>
<p>无论高级语言提供多么优美的数据模型，编译成机器代码之后，它只是简单地将内存理解为一个很大的，按照字节(8bits)寻址的数组。而机器访问内存，则都是通过地址来访问的</p>
<p>32位机器和64位机器有什么不同呢？就是说的地址总线，32位机器表明程序的地址可以占用4个字节，能够访问的地址有4GB。而64位则表明程序的地址可以占8个字节，能够访问2^64byte</p>
</blockquote>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-12-17</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Java/" title="Java">Java </a><a class="tag" href="/tags/Jvm/" title="Jvm">Jvm </a><i class="fa fa-star"></i><a class="tag" href="/categories/基础夯实/" title="基础夯实">基础夯实 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://wxxlamp.cn/2020/12/17/java-memory/,王星星的魔灯,类在内存中的存储方式,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2020/12/21/individual-and-bussiness/" title="论[工作拧螺丝]">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/12/16/hexo-guide/" title="Hexo使用指南">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false,
  verify:false|| false,
  app_id:'VzGOJC7bFNXeYUEicbM4nOT2-gzGzoHsz',
  app_key:'T3VwGNzVqiWepoUHUQMnh8tP',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>