<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="王星星"><title>SpringMVC源码分析 · 王星星的魔灯</title><meta name="description" content="前几天看了分析了@RequestBody的原理，并且DIY了一个参数解析器，今天趁热打铁，分析下SpringMVC的原理，主要包括启动流程和执行流程以及其设计思路。
SpringMVC中的MVC指的是model view 和 controller，view指的是渲染的视图，model指的是应用中包含"><meta name="keywords" content="王星星的魔灯,博客,王星星"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><!-- 增加网站logo--><link rel="shortcut icon" href="/assets/img/favicon.ico" type="image/x-icon"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.2.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">王星星的魔灯</a></h3><div class="description"><p>勇士斗恶龙 <br> Love & Seriousness & Regularity & Persistence</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com/wxxlamp"><i class="fa fa-github"></i></a></li><li><a href="mailto:wxxlamp@foxmail.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://wpa.qq.com/msgrd?v=3&amp;uin=2305450070&amp;site=qq&amp;menu=yes"><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/coder_what"><i class="fa fa-mortar-board"></i></a></li></ul><div class="footer"><div class="p"><span>© 2018 - 2023</span><i class="fa fa-star"></i><span> 王星星</span><!--span.leancloud_visitors--></div><div class="by_farbox"><span>Powered by</span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo</a><span> &</span><a href="https://github.com/wxxlamp/anatole-core-wxx" target="_blank">Anatole-Wxx</a></div><div class="beian"><a href="http://www.beian.miit.gov.cn/" target="_blank">豫ICP备20004458号-1</a><span style="height:10px;margin-left: 10px;">|</span><img src="/images/gongan.png" style="height:10px;margin-left: 10px;position: relative;top: 1px;"><span style="margin-left: 2px;">豫公网安备 44030400004458号</span></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/categories">分类</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"></a></li></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>SpringMVC源码分析</a></h3></div><div class="post-content"><p>前几天看了分析了@RequestBody的原理，并且DIY了一个参数解析器，今天趁热打铁，分析下SpringMVC的原理，主要包括启动流程和执行流程以及其设计思路。</p>
<p>SpringMVC中的MVC指的是model view 和 controller，view指的是渲染的视图，model指的是应用中包含的各种数据，controller则是负责业务处理的控制器。对于整个流程来说，当一个HTTP请求进入服务器之后，<strong>controller</strong>会对后台的数据，即<strong>model</strong>进行加工处理，然后由SpringMVC将这些<strong>model</strong>渲染为对应的<strong>view</strong>，形成response响应给client</p>
<h3 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h3><p>SpringMVC中有几个非常重要的类，分别是 <code>DispatherServlet</code>，<code>HandlerMapping</code>，<code>HandlerMethod</code>，<code>HandlerAdapter</code>，<code>HandlerExceptionResolver</code>，<code>HandlerInterceptor</code>，<code>HandlerExecutionChain</code>，<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHanlder</code></p>
<ol>
<li><code>DispatherServlet</code>负责两件事情，一个是兼容Servlet规范（实现servlet的init方法，使得MVC相关的处理器在此时初始化）；一个是使得该MVC程序可以简单实用Spring的IOC（可以获得Environment，设置Environment和ApplicationContext）。除此之外，<code>DispatherServlet</code>还负责路由之后的核心逻辑的处理</li>
<li>对于<code>HandlerMapping</code>来说，它负责将request和handlerExecutionChain关联起来，用于请求的路由处理。它的一个实现类R<code>equestMappingHandlerMapping</code>需要在初始化的时候检测@Controller注解或者@RequestMapping注解的类，将对应<code>RequestMappingInfo</code>（里面装着url的映射）和<code>HandlerMethod</code>关联起来</li>
<li><code>HandlerMethod</code>封装了对应的<code>Method</code>和持有它的bean</li>
<li><code>HandlerAdapter</code>依赖并代理了<code>HandlerMethod</code>，聚合了<code>ModelAndViewResolver</code>, <code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHanlder</code>，用于处理参数，返回值和渲染视图</li>
<li><code>HandlerExecutionChain</code>封装了<code>HandlerAdapter</code>和拦截器集合，通过它可以拿到<code>HandlerAdapter</code>，并且可以进行拦截器前置方法，后置方法和完成方法的监听和处理</li>
<li><code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHanlder</code>用户参数和返回值的个性化处理。用到的设计思想和HandlerAdapter是一样的</li>
<li>最后一步，就是要去将数据渲染为对应的视图，而这一步就是由<code>ModelAndView</code>，<code>View</code>来完成的，它负责将model以不同的方式，如Jsp，Html等渲染成view，装入response中</li>
<li>而几乎所有的框架都会有异常处理模块，SpringMVC也不例外，<code>HandlerExceptionResolver</code>则是负责这么一个处理流程的。它主要的功能就是将异常转换为合适的<code>ModelAndView</code>之后渲染到response中，而不至于出现5**的响应。其中，我们可以自定义发生异常后的响应方式。</li>
</ol>
<p>对于这几个模块，我们可以这么理解：</p>
<blockquote>
<p>对于一个普通的MVC设计思路来说，路由request和method是必不可少的，然后通过代理method的adapter来实现对参数和返回值的处理，又因为需要进行拦截器的拦截，所以需要一个interceptorChain和interceptor。最后，因为业务需要对某些异常进行特定的处理，所以我们还需要一个异常处理模块。</p>
</blockquote>
<p>这，便是SpringMVC的核心类和模块。</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>我们知道，对于Http请求来说，tomcat执行了<code>HttpServlet#service</code>方法，继承了<code>HttPServlet</code>的<code>FrameServlet</code>则是执行doService方法，而SpringMVC的<code>DispatcherServlet</code>则是继承了<code>HttpServlet</code>，进入到SpringMVC的流程中，在<code>DispatcherServlet</code>中的流程如下：</p>
<p>先通过<code>HandlerMapping</code>拿到request对应的<code>HandlerExecutionChain</code>，然后再拿到<code>HandlerExecutionChain中handler</code>对应的<code>HandlerAdapter</code>，执行<code>HandlerExecutionChain</code>中<code>interceptor#prehandle</code>方法。</p>
<p>再通过<code>handlerAdapter</code>去执行handler，handler其实对应的是之前注册的<code>HandlerMethod</code>（handlerMethod里面封装的映射的真正方法 <em>handler还有可能是原生的Servlet</em>），所以要执行handler.invoke，不过在这之前要去判断参数，这一步需要参数解析器<code>HandlerMethodArgumentResolver</code>。反射调用完之后，需要调用返回值解析器<code>HandlerMethodReturnValueHanlder</code></p>
<p>真正方法执行完了之后，再执行<code>HandlerExecutionChain中interceptor#posthandle</code>方法进行拦截器的后置处理。</p>
<p>SpringMVC执行完之后返回的是<code>ModelAndView</code>，我们还需要对<code>ModelAndView</code>进行render，即把modelAndView中的view渲染到response中</p>
<p>当发生异常时，会将异常拉到用户业务自己的异常处理方法中，这时也需要对参数和返回值进行custom，此时就需要用到<code>HandlerExceptionResolver</code>系列了。因为用户标记的<code>@ExceptionHandler</code>方法已经被<code>ExceptionHandlerMethodResolver</code>找到并且注册（key为对应异常，value为对应方法），只需要调用该方法就可以对异常进行处理，此时的方法调用和之前的handler几乎没有区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatherServlet#doDispath关于异常处理的部分源码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            ...  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理异常和渲染modelAndView的方法</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 真正处理异常的方法</span></span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><blockquote>
<p>默认使用SpringBoot的自动装备</p>
</blockquote>
<p>当我们点击SpringBoot的run之后，马老师，发绳肾么事了？</p>
<p>在回答问题之前，我们需要明白一件事情：SpringMVC在启动的时候需要利用SpringIOC的特性，同时也需要符合Servlet规范，即对servlet进行初始化。</p>
<p>SpringBoot会首先获得<code>AnnotationConfigServletWebServerApplicationContext</code>，然后进入到它的父类<code>AbstractApplicationContext#finishBeanFactoryInitialization</code>中，它会去遍历所有bean，对bean进行后置方法的处理。因为<code>RequestMappingHandlerMapping</code>需要对bean进行后置化处理，在这个过程中，它会去查找到有<code>@Controller</code>注解或者<code>@RequestMapping</code>注解的类，将对应<code>RequestMappingInfo</code>（里面装着url的映射）和<code>HandlerMethod</code>关联起来，在这个过程中，它不仅会注册用户自己标记的Controller，SpringMVC还内置了error的默认处理类<code>BasicErrorController</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 附：AbstractHandlerMethodMapping.java 部分源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detects handler methods at initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scan beans in the ApplicationContext, detect and register handler methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initHandlerMethods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   ... </span><br><span class="line">       </span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">         Class&lt;?&gt; beanType = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// An unresolvable bean type, probably from a lazy bean - let&#x27;s ignore it.</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">&quot;Could not resolve target class for bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 如果该bean有@Controller或者@RequestMapping注解，则获取它的方法</span></span><br><span class="line">         <span class="keyword">if</span> (beanType != <span class="keyword">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">            detectHandlerMethods(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 后置处理，由子类实现，目前为空</span></span><br><span class="line">   handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Look for handler methods in a handler.</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler the bean name of a handler or a handler instance</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">detectHandlerMethods</span><span class="params">(<span class="keyword">final</span> Object handler)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; handlerType = (handler <span class="keyword">instanceof</span> String ?</span><br><span class="line">			obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (handlerType != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">final</span> Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">        <span class="comment">// 将该类中的method和对应的RequestMappingInfo装入map中</span></span><br><span class="line">        Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">				(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> getMappingForMethod(method, userType);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Invalid mapping on handler class [&quot;</span> +</span><br><span class="line">								userType.getName() + <span class="string">&quot;]: &quot;</span> + method, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">				&#125;);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(methods.size() + <span class="string">&quot; request handler methods found on &quot;</span> + userType + <span class="string">&quot;: &quot;</span> + methods);</span><br><span class="line">		&#125;</span><br><span class="line">		methods.forEach((method, mapping) -&gt; &#123;</span><br><span class="line">			Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);</span><br><span class="line">            <span class="comment">// 形成HandlerMethod类，并将该类与mapping进行映射</span></span><br><span class="line">			registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，Servlet需要通过init方法进行初始化，Servlet也需要在init方法中初始化。</p>
<p>当<code>AbstractApplicationContext#finishBeanFactoryInitialization</code>执行之后，便会执行<code>AbstractApplicationContext#finishRefresh</code>，在这个过程中，它会去启动Tomcat服务器，在Tomcat启动的过程中，调用<code>StandardWrapper#loadServlet</code>，而此时，则会对DefaultServlet进行初始化，对默认Servlet进行一些属性的设置</p>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>在服务启动之后，当一个request进入我们的服务器的时候，经过一系列的Valve和Filter后，会进入<code>StandardWrapper#allocate</code>中申请Servlet，同时对DispatherServlet进行初始化，它主要执行了<code>DispatherServlet#initStrategies</code>，然后在初始化策略的过程中会初始化<code>HandlerMapping</code>，<code>HandlerAdapter</code>，<code>HandlerExceptionResolver</code>，<code>ViewResolver</code>等等。在这个过程中，如果有对应的bean则获取，如果没有则拿到dispatcherServlet.properties中的默认策略</p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><ol>
<li><p>SpringMVC中大量使用工厂模式，组合模式，策略模式和过滤器链模式等等，包括且不限于异常处理模块，参数解析和返回值渲染模块，方法代理模块（这个模块还用了代理模式）等等，它常见的表现形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolve</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    List&lt;Handler&gt; handlerList;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Handler handler: handlerList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(handler.supports(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolve</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(Handler handler: handlerList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(handler.supports(obj)) &#123;</span><br><span class="line">                <span class="keyword">return</span> handler.resolve(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiyHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在责任链模式的使用过程中，我发现SpringMVC的过滤器链和Tomcat的还有一些不同，Tomcat的过滤器模式比较正统，而对于SpringMVC的责任链中，它其实只是起了一个拦截器的作用，只用到了两个类就实现了，即<code>HandlerInterceptor</code>和<code>HandlerExecutionChain</code>，前者有多个实现类，对应着多个不同种类的拦截器。而Tomcat当中，有两种方式实现了责任链模式，一个是pipeline/valve（valve的多个实现类对应着不同的水阀），另一个是filterChain/filter/filterConfig（chain负责调度多个filter并执行，filterConfig聚合了filter及其配置）</p>
</li>
<li><p>同时，大量的Map形式或者类形式(如Match类)的缓存也是必须的</p>
</li>
</ol>
<h3 id="采坑点"><a href="#采坑点" class="headerlink" title="采坑点"></a>采坑点</h3><ol>
<li>看SpringMVC最好不要直接用SpringBoot来看，它有自动装配，会让人看源码看的更加复杂</li>
<li>&lt;—- 参数和返回值  **依赖关系**  和 &lt;—&lt;&gt; 属性   <strong>聚合关系</strong></li>
<li>Spring的BeanFactory和ApplicationContext，ApplicationListener，Environment和这四个对应的Aware接口</li>
<li>spring-web和spring-webmvc的依赖的区别，前者是将spring应用的web环境中，后者是实现web中的spring模式</li>
<li>目前狭义上的SpringMVC是由服务端来负责渲染。从狭义上说，目前被大家广泛接受的前后端分离的形式，即后台只给前端传递json数据，这样是不属于MVC模式的，因为我们是直接把model转化为json传递给前端，由前端渲染。从源码中我们也可以看到，SpringMVC如果返回json数据的时候，返回的ModelAndView类是空的。所以我就产生了这样一个念头，简化SpringMVC</li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2021-02-17</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Java/" title="Java">Java </a><a class="tag" href="/tags/SpringMVC/" title="SpringMVC">SpringMVC </a><a class="tag" href="/tags/Spring/" title="Spring">Spring </a><i class="fa fa-star"></i><a class="tag" href="/categories/源码剖析/" title="源码剖析">源码剖析 </a><span class="leancloud_visitors"></span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://wxxlamp.cn/2021/02/17/spring-mvc-desc/,王星星的魔灯,SpringMVC源码分析,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2021/02/25/ali-22-internships/" title="搞Java，来这就对了！">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2021/01/27/annotation-requestbody/" title="@RequestBody的原理">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false,
  verify:false|| false,
  app_id:'VzGOJC7bFNXeYUEicbM4nOT2-gzGzoHsz',
  app_key:'T3VwGNzVqiWepoUHUQMnh8tP',
  placeholder:'念念不忘，必有回响...',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'mp'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script src="/js/baidu-tongji.js"></script></body></html>